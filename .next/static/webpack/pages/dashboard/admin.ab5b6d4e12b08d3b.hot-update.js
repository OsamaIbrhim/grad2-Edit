"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/dashboard/admin",{

/***/ "./utils/contracts.ts":
/*!****************************!*\
  !*** ./utils/contracts.ts ***!
  \****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createExam: function() { return /* binding */ createExam; },\n/* harmony export */   enrollStudent: function() { return /* binding */ enrollStudent; },\n/* harmony export */   getCertificates: function() { return /* binding */ getCertificates; },\n/* harmony export */   getContracts: function() { return /* binding */ getContracts; },\n/* harmony export */   getExam: function() { return /* binding */ getExam; },\n/* harmony export */   getExamResult: function() { return /* binding */ getExamResult; },\n/* harmony export */   getInstitutionExams: function() { return /* binding */ getInstitutionExams; },\n/* harmony export */   getOwnerAddress: function() { return /* binding */ getOwnerAddress; },\n/* harmony export */   getStudentExams: function() { return /* binding */ getStudentExams; },\n/* harmony export */   getUserRole: function() { return /* binding */ getUserRole; },\n/* harmony export */   isOwner: function() { return /* binding */ isOwner; },\n/* harmony export */   isVerifiedUser: function() { return /* binding */ isVerifiedUser; },\n/* harmony export */   issueCertificate: function() { return /* binding */ issueCertificate; },\n/* harmony export */   registerUser: function() { return /* binding */ registerUser; },\n/* harmony export */   submitExamResult: function() { return /* binding */ submitExamResult; },\n/* harmony export */   updateExamStatus: function() { return /* binding */ updateExamStatus; },\n/* harmony export */   verifyCertificate: function() { return /* binding */ verifyCertificate; },\n/* harmony export */   verifyInstitution: function() { return /* binding */ verifyInstitution; },\n/* harmony export */   verifyUser: function() { return /* binding */ verifyUser; }\n/* harmony export */ });\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ethers */ \"./node_modules/ethers/lib.esm/index.js\");\n/* harmony import */ var _constants_abis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/abis */ \"./constants/abis.ts\");\n/* harmony import */ var _ethersConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ethersConfig */ \"./utils/ethersConfig.ts\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"./node_modules/process/browser.js\");\n\n\n\n// Contract ABIs\nconst IdentityABI = [\n    \"function registerUser(uint8 _role, string memory _ipfsHash) external\",\n    \"function verifyUser(address _userAddress) external returns (bool)\",\n    \"function getUserRole(address _userAddress) external view returns (uint8)\",\n    \"function isVerifiedUser(address _userAddress) external view returns (bool)\",\n    \"function updateUserIPFS(string memory _newIpfsHash) external\",\n    // \"function owner() external view returns (address)\"\n    \"function owner() view returns (address)\"\n];\nconst CertificatesABI = [\n    \"function issueCertificate(address _studentAddress, string memory _ipfsHash) external returns (bytes32)\",\n    \"function getStudentCertificates(address _student) external view returns (bytes32[])\",\n    \"function verifyCertificate(bytes32 _certificateId) external view returns (address student, address institution, string ipfsHash, uint256 issuedAt, bool isValid)\"\n];\n// Contract addresses from .env\nconst IDENTITY_CONTRACT_ADDRESS = \"0xaaC5DcdAeadEe8aA2eE7C7c6F381AB44948963B5\";\nconst CERTIFICATES_CONTRACT_ADDRESS = \"0x2AA6Bc8e926Ee5ECaA24c3B29cf24A3e32380682\";\n// Role mapping with proper types\nconst USER_ROLES = {\n    NONE: 0,\n    STUDENT: 1,\n    INSTITUTION: 2,\n    EMPLOYER: 3\n};\nconst roleMap = {\n    [USER_ROLES.NONE]: \"none\",\n    [USER_ROLES.STUDENT]: \"student\",\n    [USER_ROLES.INSTITUTION]: \"institution\",\n    [USER_ROLES.EMPLOYER]: \"employer\"\n};\n// Validate environment variables\nif (!IDENTITY_CONTRACT_ADDRESS) {\n    console.error(\"NEXT_PUBLIC_IDENTITY_CONTRACT_ADDRESS is not set in .env\");\n}\nif (!CERTIFICATES_CONTRACT_ADDRESS) {\n    console.error(\"NEXT_PUBLIC_CERTIFICATES_CONTRACT_ADDRESS is not set in .env\");\n}\nconst getContracts = async ()=>{\n    try {\n        const provider = await (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.getProvider)();\n        const signer = await (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.getSigner)();\n        const identityContract = new ethers__WEBPACK_IMPORTED_MODULE_2__.ethers.Contract(IDENTITY_CONTRACT_ADDRESS, IdentityABI, signer);\n        const certificatesContract = new ethers__WEBPACK_IMPORTED_MODULE_2__.ethers.Contract(CERTIFICATES_CONTRACT_ADDRESS, CertificatesABI, signer);\n        return {\n            identityContract,\n            certificatesContract,\n            provider,\n            signer\n        };\n    } catch (error) {\n        console.error(\"Error initializing contracts:\", error);\n        throw new Error(\"Failed to initialize contracts: \".concat(error.message));\n    }\n};\nconst registerUser = async (role)=>{\n    if (!role) {\n        throw new Error(\"Role is required\");\n    }\n    try {\n        const provider = await (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.getProvider)();\n        const signer = await (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.getSigner)();\n        signer.address.toLowerCase();\n        const contractAddress = \"0xaaC5DcdAeadEe8aA2eE7C7c6F381AB44948963B5\";\n        if (!contractAddress) {\n            throw new Error(\"Contract address is not configured\");\n        }\n        const contract = new ethers__WEBPACK_IMPORTED_MODULE_2__.ethers.Contract(contractAddress, IdentityABI, signer);\n        // Convert role string to enum value\n        const roleMap = {\n            \"student\": 1,\n            \"institution\": 2,\n            \"employer\": 3\n        };\n        const roleValue = roleMap[role.toLowerCase()];\n        if (roleValue === undefined) {\n            throw new Error(\"Invalid role: \".concat(role, \". Must be one of: student, institution, employer\"));\n        }\n        const tx = await contract.registerUser(roleValue, \"\");\n        await tx.wait();\n        return {\n            status: \"success\"\n        };\n    } catch (error) {\n        console.error(\"Registration error:\", error);\n        throw error;\n    }\n};\nconst verifyUser = async (address)=>{\n    if (!address || !(0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.getAddress)(address)) {\n        throw new Error(\"Invalid address\");\n    }\n    try {\n        const { identityContract } = await getContracts();\n        return await identityContract.verifyUser(address);\n    } catch (error) {\n        console.error(\"Error verifying user:\", error);\n        throw new Error(error.message || \"Failed to verify user\");\n    }\n};\nconst getUserRole = async (address)=>{\n    if (!address || !(0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.getAddress)(address)) {\n        throw new Error(\"Invalid address\");\n    }\n    try {\n        const { identityContract } = await getContracts();\n        const roleValue = await identityContract.getUserRole(address);\n        return roleMap[roleValue] || \"none\";\n    } catch (error) {\n        console.error(\"Error getting user role:\", error);\n        return \"none\";\n    }\n};\nconst issueCertificate = async (studentAddress, ipfsHash)=>{\n    if (!studentAddress || !ipfsHash) {\n        throw new Error(\"Student address and IPFS hash are required\");\n    }\n    try {\n        const { certificatesContract } = await getContracts();\n        const tx = await certificatesContract.issueCertificate(studentAddress, ipfsHash);\n        await tx.wait();\n        return tx;\n    } catch (error) {\n        console.error(\"Error issuing certificate:\", error);\n        throw error;\n    }\n};\nconst verifyCertificate = async (certificateId)=>{\n    if (!certificateId) {\n        throw new Error(\"Certificate ID is required\");\n    }\n    try {\n        const { certificatesContract } = await getContracts();\n        const isValid = await certificatesContract.verifyCertificate(certificateId);\n        return isValid;\n    } catch (error) {\n        console.error(\"Error verifying certificate:\", error);\n        throw error;\n    }\n};\nconst getCertificates = async (address)=>{\n    if (!address || !(0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.getAddress)(address)) {\n        throw new Error(\"Invalid address\");\n    }\n    try {\n        console.log(\"Getting certificates for address:\", address);\n        const { certificatesContract } = await getContracts();\n        // Get certificate IDs first\n        console.log(\"Getting certificate IDs...\");\n        const certificateIds = await certificatesContract.getStudentCertificates(address);\n        console.log(\"Certificate IDs:\", certificateIds);\n        if (!certificateIds || certificateIds.length === 0) {\n            console.log(\"No certificates found\");\n            return [];\n        }\n        // Get details for each certificate\n        console.log(\"Getting certificate details...\");\n        const certificates = await Promise.all(certificateIds.map(async (id)=>{\n            const cert = await certificatesContract.verifyCertificate(id);\n            return {\n                id,\n                ipfsHash: cert.ipfsHash,\n                issuer: cert.institution,\n                timestamp: cert.issuedAt.toString(),\n                isValid: cert.isValid\n            };\n        }));\n        console.log(\"Certificate details:\", certificates);\n        return certificates;\n    } catch (error) {\n        console.error(\"Error in getCertificates:\", error);\n        if (error.reason) {\n            throw new Error(\"Contract error: \".concat(error.reason));\n        }\n        throw error;\n    }\n};\nconst isVerifiedUser = async (address)=>{\n    if (!address || !(0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.getAddress)(address)) {\n        throw new Error(\"Invalid address\");\n    }\n    try {\n        const { identityContract } = await getContracts();\n        return await identityContract.isVerifiedUser(address);\n    } catch (error) {\n        console.error(\"Error checking verification status:\", error);\n        throw error;\n    }\n};\n// Admin functions\nconst isOwner = async (address)=>{\n    if (!address || !(0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.getAddress)(address)) {\n        throw new Error(\"Invalid address\");\n    }\n    try {\n        const { identityContract } = await getContracts();\n        const owner = await identityContract.owner();\n        // Add additional checks\n        if (!owner) {\n            console.warn(\"Owner address is null or undefined\");\n            return false;\n        }\n        return owner.toLowerCase() === address.toLowerCase();\n    } catch (error) {\n        console.error(\"Error checking owner status:\", error);\n        throw error;\n    }\n};\nconst verifyInstitution = async (institutionAddress)=>{\n    if (!institutionAddress || !(0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.getAddress)(institutionAddress)) {\n        throw new Error(\"Invalid institution address\");\n    }\n    try {\n        const { identityContract } = await getContracts();\n        const tx = await identityContract.verifyUser(institutionAddress);\n        await tx.wait();\n        return tx;\n    } catch (error) {\n        console.error(\"Error verifying institution:\", error);\n        throw error;\n    }\n};\nconst getOwnerAddress = async ()=>{\n    try {\n        const { identityContract } = await getContracts();\n        const owner = await identityContract.owner();\n        return owner;\n    } catch (error) {\n        console.error(\"Error getting owner address:\", error);\n        throw error;\n    }\n};\n// Add exam management contract address and ABI\nconst EXAM_MANAGEMENT_ADDRESS = process.env.NEXT_PUBLIC_EXAM_MANAGEMENT_ADDRESS || \"\";\nconst EXAM_MANAGEMENT_ABI = _constants_abis__WEBPACK_IMPORTED_MODULE_0__.ExamManagementABI;\n// Add exam management functions\nconst createExam = async (id, title, description, date, duration, ipfsHash)=>{\n    try {\n        if (!window.ethereum) {\n            throw new Error(\"No ethereum provider found\");\n        }\n        const provider = new ethers__WEBPACK_IMPORTED_MODULE_2__.ethers.JsonRpcProvider(_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.EXPECTED_NETWORK.rpcUrl);\n        const signer = await provider.getSigner();\n        const contract = new ethers__WEBPACK_IMPORTED_MODULE_2__.ethers.Contract(EXAM_MANAGEMENT_ADDRESS, EXAM_MANAGEMENT_ABI, signer);\n        const tx = await contract.createExam(id, title, description, date, duration, ipfsHash);\n        await tx.wait();\n        return true;\n    } catch (error) {\n        console.error(\"Error creating exam:\", error);\n        throw error;\n    }\n};\nconst submitExamResult = async (examId, student, score, grade, ipfsHash)=>{\n    try {\n        if (!window.ethereum) {\n            throw new Error(\"No ethereum provider found\");\n        }\n        const provider = new ethers__WEBPACK_IMPORTED_MODULE_2__.ethers.JsonRpcProvider(_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.EXPECTED_NETWORK.rpcUrl);\n        const signer = await provider.getSigner();\n        const contract = new ethers__WEBPACK_IMPORTED_MODULE_2__.ethers.Contract(EXAM_MANAGEMENT_ADDRESS, EXAM_MANAGEMENT_ABI, signer);\n        const tx = await contract.submitExamResult(examId, student, score, grade, ipfsHash);\n        await tx.wait();\n        return true;\n    } catch (error) {\n        console.error(\"Error submitting exam result:\", error);\n        throw error;\n    }\n};\nconst updateExamStatus = async (examId, status)=>{\n    try {\n        if (!window.ethereum) {\n            throw new Error(\"No ethereum provider found\");\n        }\n        const provider = new ethers__WEBPACK_IMPORTED_MODULE_2__.ethers.JsonRpcProvider(_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.EXPECTED_NETWORK.rpcUrl);\n        const signer = await provider.getSigner();\n        const contract = new ethers__WEBPACK_IMPORTED_MODULE_2__.ethers.Contract(EXAM_MANAGEMENT_ADDRESS, EXAM_MANAGEMENT_ABI, signer);\n        const tx = await contract.updateExamStatus(examId, status);\n        await tx.wait();\n        return true;\n    } catch (error) {\n        console.error(\"Error updating exam status:\", error);\n        throw error;\n    }\n};\nconst getExam = async (examId)=>{\n    try {\n        if (!window.ethereum) {\n            throw new Error(\"No ethereum provider found\");\n        }\n        const provider = new ethers__WEBPACK_IMPORTED_MODULE_2__.ethers.JsonRpcProvider(_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.EXPECTED_NETWORK.rpcUrl);\n        const contract = new ethers__WEBPACK_IMPORTED_MODULE_2__.ethers.Contract(EXAM_MANAGEMENT_ADDRESS, EXAM_MANAGEMENT_ABI, provider);\n        const exam = await contract.getExam(examId);\n        return exam;\n    } catch (error) {\n        console.error(\"Error getting exam:\", error);\n        throw error;\n    }\n};\nconst getExamResult = async (examId, student)=>{\n    try {\n        if (!window.ethereum) {\n            throw new Error(\"No ethereum provider found\");\n        }\n        const provider = new ethers__WEBPACK_IMPORTED_MODULE_2__.ethers.JsonRpcProvider(_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.EXPECTED_NETWORK.rpcUrl);\n        const contract = new ethers__WEBPACK_IMPORTED_MODULE_2__.ethers.Contract(EXAM_MANAGEMENT_ADDRESS, EXAM_MANAGEMENT_ABI, provider);\n        const result = await contract.getExamResult(examId, student);\n        return result;\n    } catch (error) {\n        console.error(\"Error getting exam result:\", error);\n        throw error;\n    }\n};\nconst getInstitutionExams = async (institution)=>{\n    try {\n        if (!window.ethereum) {\n            throw new Error(\"No ethereum provider found\");\n        }\n        const provider = new ethers__WEBPACK_IMPORTED_MODULE_2__.ethers.JsonRpcProvider(_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.EXPECTED_NETWORK.rpcUrl);\n        const contract = new ethers__WEBPACK_IMPORTED_MODULE_2__.ethers.Contract(EXAM_MANAGEMENT_ADDRESS, EXAM_MANAGEMENT_ABI, provider);\n        const exams = await contract.getInstitutionExams(institution);\n        return exams;\n    } catch (error) {\n        console.error(\"Error getting institution exams:\", error);\n        throw error;\n    }\n};\nconst getStudentExams = async (student)=>{\n    try {\n        if (!window.ethereum) {\n            throw new Error(\"No ethereum provider found\");\n        }\n        const provider = new ethers__WEBPACK_IMPORTED_MODULE_2__.ethers.JsonRpcProvider(_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.EXPECTED_NETWORK.rpcUrl);\n        const contract = new ethers__WEBPACK_IMPORTED_MODULE_2__.ethers.Contract(EXAM_MANAGEMENT_ADDRESS, EXAM_MANAGEMENT_ABI, provider);\n        const exams = await contract.getStudentExams(student);\n        return exams;\n    } catch (error) {\n        console.error(\"Error getting student exams:\", error);\n        throw error;\n    }\n};\nconst enrollStudent = async (examId, studentAddress)=>{\n    try {\n        if (!window.ethereum) {\n            throw new Error(\"No ethereum provider found\");\n        }\n        const provider = new ethers__WEBPACK_IMPORTED_MODULE_2__.ethers.JsonRpcProvider(_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.EXPECTED_NETWORK.rpcUrl);\n        const signer = await provider.getSigner();\n        const contract = new ethers__WEBPACK_IMPORTED_MODULE_2__.ethers.Contract(EXAM_MANAGEMENT_ADDRESS, EXAM_MANAGEMENT_ABI, signer);\n        const tx = await contract.enrollStudent(examId, studentAddress);\n        await tx.wait();\n        return true;\n    } catch (error) {\n        console.error(\"Error enrolling student:\", error);\n        throw error;\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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Z0YsTUFBTTtRQUNuRSxNQUFNNUQsU0FBUyxNQUFNRCxTQUFTcEIsU0FBUztRQUN2QyxNQUFNZ0MsV0FBVyxJQUFJbkMsMENBQU1BLENBQUMwQixRQUFRLENBQUMrQyx5QkFBeUJFLHFCQUFxQm5EO1FBRW5GLE1BQU1jLEtBQUssTUFBTUgsU0FBUytELGFBQWEsQ0FBQ1osUUFBUTFDO1FBQ2hELE1BQU1OLEdBQUdDLElBQUk7UUFDYixPQUFPO0lBQ1QsRUFBRSxPQUFPbEIsT0FBTztRQUNkRCxRQUFRQyxLQUFLLENBQUMsNEJBQTRCQTtRQUMxQyxNQUFNQTtJQUNSO0FBQ0YsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi91dGlscy9jb250cmFjdHMudHM/OTg1NiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBldGhlcnMgfSBmcm9tICdldGhlcnMnO1xuaW1wb3J0IHsgRXhhbU1hbmFnZW1lbnRBQkkgfSBmcm9tICcuLi9jb25zdGFudHMvYWJpcyc7XG5pbXBvcnQge1xuICBnZXRQcm92aWRlcixcbiAgZ2V0U2lnbmVyLFxuICBFWFBFQ1RFRF9ORVRXT1JLLFxuICB2YWxpZGF0ZU5ldHdvcmssXG4gIGZvcm1hdEV0aGVyLFxuICBoYW5kbGVDb250cmFjdEVycm9yLFxuICBnZXRBZGRyZXNzLFxuICB0eXBlIEV0aGVyZXVtUHJvdmlkZXJcbn0gZnJvbSAnLi9ldGhlcnNDb25maWcnO1xuXG4vLyBDb250cmFjdCBBQklzXG5jb25zdCBJZGVudGl0eUFCSSA9IFtcbiAgXCJmdW5jdGlvbiByZWdpc3RlclVzZXIodWludDggX3JvbGUsIHN0cmluZyBtZW1vcnkgX2lwZnNIYXNoKSBleHRlcm5hbFwiLFxuICBcImZ1bmN0aW9uIHZlcmlmeVVzZXIoYWRkcmVzcyBfdXNlckFkZHJlc3MpIGV4dGVybmFsIHJldHVybnMgKGJvb2wpXCIsXG4gIFwiZnVuY3Rpb24gZ2V0VXNlclJvbGUoYWRkcmVzcyBfdXNlckFkZHJlc3MpIGV4dGVybmFsIHZpZXcgcmV0dXJucyAodWludDgpXCIsXG4gIFwiZnVuY3Rpb24gaXNWZXJpZmllZFVzZXIoYWRkcmVzcyBfdXNlckFkZHJlc3MpIGV4dGVybmFsIHZpZXcgcmV0dXJucyAoYm9vbClcIixcbiAgXCJmdW5jdGlvbiB1cGRhdGVVc2VySVBGUyhzdHJpbmcgbWVtb3J5IF9uZXdJcGZzSGFzaCkgZXh0ZXJuYWxcIixcbiAgLy8gXCJmdW5jdGlvbiBvd25lcigpIGV4dGVybmFsIHZpZXcgcmV0dXJucyAoYWRkcmVzcylcIlxuICBcImZ1bmN0aW9uIG93bmVyKCkgdmlldyByZXR1cm5zIChhZGRyZXNzKVwiXG5dO1xuXG5jb25zdCBDZXJ0aWZpY2F0ZXNBQkkgPSBbXG4gIFwiZnVuY3Rpb24gaXNzdWVDZXJ0aWZpY2F0ZShhZGRyZXNzIF9zdHVkZW50QWRkcmVzcywgc3RyaW5nIG1lbW9yeSBfaXBmc0hhc2gpIGV4dGVybmFsIHJldHVybnMgKGJ5dGVzMzIpXCIsXG4gIFwiZnVuY3Rpb24gZ2V0U3R1ZGVudENlcnRpZmljYXRlcyhhZGRyZXNzIF9zdHVkZW50KSBleHRlcm5hbCB2aWV3IHJldHVybnMgKGJ5dGVzMzJbXSlcIixcbiAgXCJmdW5jdGlvbiB2ZXJpZnlDZXJ0aWZpY2F0ZShieXRlczMyIF9jZXJ0aWZpY2F0ZUlkKSBleHRlcm5hbCB2aWV3IHJldHVybnMgKGFkZHJlc3Mgc3R1ZGVudCwgYWRkcmVzcyBpbnN0aXR1dGlvbiwgc3RyaW5nIGlwZnNIYXNoLCB1aW50MjU2IGlzc3VlZEF0LCBib29sIGlzVmFsaWQpXCJcbl07XG5cbi8vIENvbnRyYWN0IGFkZHJlc3NlcyBmcm9tIC5lbnZcbmNvbnN0IElERU5USVRZX0NPTlRSQUNUX0FERFJFU1MgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19JREVOVElUWV9DT05UUkFDVF9BRERSRVNTO1xuY29uc3QgQ0VSVElGSUNBVEVTX0NPTlRSQUNUX0FERFJFU1MgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19DRVJUSUZJQ0FURVNfQ09OVFJBQ1RfQUREUkVTUztcblxuLy8gUm9sZSBtYXBwaW5nIHdpdGggcHJvcGVyIHR5cGVzXG5jb25zdCBVU0VSX1JPTEVTID0ge1xuICBOT05FOiAwLFxuICBTVFVERU5UOiAxLFxuICBJTlNUSVRVVElPTjogMixcbiAgRU1QTE9ZRVI6IDNcbn0gYXMgY29uc3Q7XG5cbnR5cGUgUm9sZVZhbHVlID0gdHlwZW9mIFVTRVJfUk9MRVNba2V5b2YgdHlwZW9mIFVTRVJfUk9MRVNdO1xudHlwZSBSb2xlU3RyaW5nID0gJ25vbmUnIHwgJ3N0dWRlbnQnIHwgJ2luc3RpdHV0aW9uJyB8ICdlbXBsb3llcic7XG5cbmNvbnN0IHJvbGVNYXA6IFJlY29yZDxSb2xlVmFsdWUsIFJvbGVTdHJpbmc+ID0ge1xuICBbVVNFUl9ST0xFUy5OT05FXTogJ25vbmUnLFxuICBbVVNFUl9ST0xFUy5TVFVERU5UXTogJ3N0dWRlbnQnLFxuICBbVVNFUl9ST0xFUy5JTlNUSVRVVElPTl06ICdpbnN0aXR1dGlvbicsXG4gIFtVU0VSX1JPTEVTLkVNUExPWUVSXTogJ2VtcGxveWVyJ1xufTtcblxuLy8gVmFsaWRhdGUgZW52aXJvbm1lbnQgdmFyaWFibGVzXG5pZiAoIUlERU5USVRZX0NPTlRSQUNUX0FERFJFU1MpIHtcbiAgY29uc29sZS5lcnJvcignTkVYVF9QVUJMSUNfSURFTlRJVFlfQ09OVFJBQ1RfQUREUkVTUyBpcyBub3Qgc2V0IGluIC5lbnYnKTtcbn1cbmlmICghQ0VSVElGSUNBVEVTX0NPTlRSQUNUX0FERFJFU1MpIHtcbiAgY29uc29sZS5lcnJvcignTkVYVF9QVUJMSUNfQ0VSVElGSUNBVEVTX0NPTlRSQUNUX0FERFJFU1MgaXMgbm90IHNldCBpbiAuZW52Jyk7XG59XG5cbmV4cG9ydCBjb25zdCBnZXRDb250cmFjdHMgPSBhc3luYyAoKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcHJvdmlkZXIgPSBhd2FpdCBnZXRQcm92aWRlcigpO1xuICAgIGNvbnN0IHNpZ25lciA9IGF3YWl0IGdldFNpZ25lcigpO1xuXG4gICAgY29uc3QgaWRlbnRpdHlDb250cmFjdCA9IG5ldyBldGhlcnMuQ29udHJhY3QoXG4gICAgICBJREVOVElUWV9DT05UUkFDVF9BRERSRVNTISxcbiAgICAgIElkZW50aXR5QUJJLFxuICAgICAgc2lnbmVyXG4gICAgKTtcblxuICAgIGNvbnN0IGNlcnRpZmljYXRlc0NvbnRyYWN0ID0gbmV3IGV0aGVycy5Db250cmFjdChcbiAgICAgIENFUlRJRklDQVRFU19DT05UUkFDVF9BRERSRVNTISxcbiAgICAgIENlcnRpZmljYXRlc0FCSSxcbiAgICAgIHNpZ25lclxuICAgICk7XG5cbiAgICByZXR1cm4geyBpZGVudGl0eUNvbnRyYWN0LCBjZXJ0aWZpY2F0ZXNDb250cmFjdCwgcHJvdmlkZXIsIHNpZ25lciB9O1xuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgaW5pdGlhbGl6aW5nIGNvbnRyYWN0czonLCBlcnJvcik7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gaW5pdGlhbGl6ZSBjb250cmFjdHM6ICR7ZXJyb3IubWVzc2FnZX1gKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IHJlZ2lzdGVyVXNlciA9IGFzeW5jIChyb2xlOiBzdHJpbmcpID0+IHtcbiAgaWYgKCFyb2xlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdSb2xlIGlzIHJlcXVpcmVkJyk7XG4gIH1cblxuICB0cnkge1xuICAgIGNvbnN0IHByb3ZpZGVyID0gYXdhaXQgZ2V0UHJvdmlkZXIoKTtcbiAgICBjb25zdCBzaWduZXIgPSBhd2FpdCBnZXRTaWduZXIoKTtcbiAgICBzaWduZXIuYWRkcmVzcy50b0xvd2VyQ2FzZSgpO1xuICAgIGNvbnN0IGNvbnRyYWN0QWRkcmVzcyA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0lERU5USVRZX0NPTlRSQUNUX0FERFJFU1M7XG5cbiAgICBpZiAoIWNvbnRyYWN0QWRkcmVzcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdDb250cmFjdCBhZGRyZXNzIGlzIG5vdCBjb25maWd1cmVkJyk7XG4gICAgfVxuXG4gICAgY29uc3QgY29udHJhY3QgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KGNvbnRyYWN0QWRkcmVzcywgSWRlbnRpdHlBQkksIHNpZ25lcik7XG5cbiAgICAvLyBDb252ZXJ0IHJvbGUgc3RyaW5nIHRvIGVudW0gdmFsdWVcbiAgICBjb25zdCByb2xlTWFwOiB7IFtrZXk6IHN0cmluZ106IG51bWJlciB9ID0ge1xuICAgICAgJ3N0dWRlbnQnOiAxLFxuICAgICAgJ2luc3RpdHV0aW9uJzogMixcbiAgICAgICdlbXBsb3llcic6IDNcbiAgICB9O1xuXG4gICAgY29uc3Qgcm9sZVZhbHVlID0gcm9sZU1hcFtyb2xlLnRvTG93ZXJDYXNlKCldO1xuICAgIGlmIChyb2xlVmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHJvbGU6ICR7cm9sZX0uIE11c3QgYmUgb25lIG9mOiBzdHVkZW50LCBpbnN0aXR1dGlvbiwgZW1wbG95ZXJgKTtcbiAgICB9XG5cbiAgICBjb25zdCB0eCA9IGF3YWl0IGNvbnRyYWN0LnJlZ2lzdGVyVXNlcihyb2xlVmFsdWUsIFwiXCIpO1xuICAgIGF3YWl0IHR4LndhaXQoKTtcbiAgICByZXR1cm4geyBzdGF0dXM6ICdzdWNjZXNzJyB9O1xuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgY29uc29sZS5lcnJvcignUmVnaXN0cmF0aW9uIGVycm9yOicsIGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IHZlcmlmeVVzZXIgPSBhc3luYyAoYWRkcmVzczogc3RyaW5nKSA9PiB7XG4gIGlmICghYWRkcmVzcyB8fCAhZ2V0QWRkcmVzcyhhZGRyZXNzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhZGRyZXNzJyk7XG4gIH1cblxuICB0cnkge1xuICAgIGNvbnN0IHsgaWRlbnRpdHlDb250cmFjdCB9ID0gYXdhaXQgZ2V0Q29udHJhY3RzKCk7XG4gICAgcmV0dXJuIGF3YWl0IGlkZW50aXR5Q29udHJhY3QudmVyaWZ5VXNlcihhZGRyZXNzKTtcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHZlcmlmeWluZyB1c2VyOicsIGVycm9yKTtcbiAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3IubWVzc2FnZSB8fCAnRmFpbGVkIHRvIHZlcmlmeSB1c2VyJyk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBnZXRVc2VyUm9sZSA9IGFzeW5jIChhZGRyZXNzOiBzdHJpbmcpOiBQcm9taXNlPFJvbGVTdHJpbmc+ID0+IHtcbiAgaWYgKCFhZGRyZXNzIHx8ICFnZXRBZGRyZXNzKGFkZHJlc3MpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFkZHJlc3MnKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgY29uc3QgeyBpZGVudGl0eUNvbnRyYWN0IH0gPSBhd2FpdCBnZXRDb250cmFjdHMoKTtcbiAgICBjb25zdCByb2xlVmFsdWUgPSBhd2FpdCBpZGVudGl0eUNvbnRyYWN0LmdldFVzZXJSb2xlKGFkZHJlc3MpO1xuICAgIHJldHVybiByb2xlTWFwW3JvbGVWYWx1ZSBhcyBSb2xlVmFsdWVdIHx8ICdub25lJztcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgdXNlciByb2xlOicsIGVycm9yKTtcbiAgICByZXR1cm4gJ25vbmUnO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgaXNzdWVDZXJ0aWZpY2F0ZSA9IGFzeW5jIChzdHVkZW50QWRkcmVzczogc3RyaW5nLCBpcGZzSGFzaDogc3RyaW5nKSA9PiB7XG4gIGlmICghc3R1ZGVudEFkZHJlc3MgfHwgIWlwZnNIYXNoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdTdHVkZW50IGFkZHJlc3MgYW5kIElQRlMgaGFzaCBhcmUgcmVxdWlyZWQnKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgY29uc3QgeyBjZXJ0aWZpY2F0ZXNDb250cmFjdCB9ID0gYXdhaXQgZ2V0Q29udHJhY3RzKCk7XG4gICAgY29uc3QgdHggPSBhd2FpdCBjZXJ0aWZpY2F0ZXNDb250cmFjdC5pc3N1ZUNlcnRpZmljYXRlKHN0dWRlbnRBZGRyZXNzLCBpcGZzSGFzaCk7XG4gICAgYXdhaXQgdHgud2FpdCgpO1xuICAgIHJldHVybiB0eDtcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGlzc3VpbmcgY2VydGlmaWNhdGU6JywgZXJyb3IpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgdmVyaWZ5Q2VydGlmaWNhdGUgPSBhc3luYyAoY2VydGlmaWNhdGVJZDogc3RyaW5nKSA9PiB7XG4gIGlmICghY2VydGlmaWNhdGVJZCkge1xuICAgIHRocm93IG5ldyBFcnJvcignQ2VydGlmaWNhdGUgSUQgaXMgcmVxdWlyZWQnKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgY29uc3QgeyBjZXJ0aWZpY2F0ZXNDb250cmFjdCB9ID0gYXdhaXQgZ2V0Q29udHJhY3RzKCk7XG4gICAgY29uc3QgaXNWYWxpZCA9IGF3YWl0IGNlcnRpZmljYXRlc0NvbnRyYWN0LnZlcmlmeUNlcnRpZmljYXRlKGNlcnRpZmljYXRlSWQpO1xuICAgIHJldHVybiBpc1ZhbGlkO1xuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgdmVyaWZ5aW5nIGNlcnRpZmljYXRlOicsIGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGdldENlcnRpZmljYXRlcyA9IGFzeW5jIChhZGRyZXNzOiBzdHJpbmcpID0+IHtcbiAgaWYgKCFhZGRyZXNzIHx8ICFnZXRBZGRyZXNzKGFkZHJlc3MpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFkZHJlc3MnKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgY29uc29sZS5sb2coJ0dldHRpbmcgY2VydGlmaWNhdGVzIGZvciBhZGRyZXNzOicsIGFkZHJlc3MpO1xuICAgIGNvbnN0IHsgY2VydGlmaWNhdGVzQ29udHJhY3QgfSA9IGF3YWl0IGdldENvbnRyYWN0cygpO1xuXG4gICAgLy8gR2V0IGNlcnRpZmljYXRlIElEcyBmaXJzdFxuICAgIGNvbnNvbGUubG9nKCdHZXR0aW5nIGNlcnRpZmljYXRlIElEcy4uLicpO1xuICAgIGNvbnN0IGNlcnRpZmljYXRlSWRzID0gYXdhaXQgY2VydGlmaWNhdGVzQ29udHJhY3QuZ2V0U3R1ZGVudENlcnRpZmljYXRlcyhhZGRyZXNzKTtcbiAgICBjb25zb2xlLmxvZygnQ2VydGlmaWNhdGUgSURzOicsIGNlcnRpZmljYXRlSWRzKTtcblxuICAgIGlmICghY2VydGlmaWNhdGVJZHMgfHwgY2VydGlmaWNhdGVJZHMubGVuZ3RoID09PSAwKSB7XG4gICAgICBjb25zb2xlLmxvZygnTm8gY2VydGlmaWNhdGVzIGZvdW5kJyk7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgLy8gR2V0IGRldGFpbHMgZm9yIGVhY2ggY2VydGlmaWNhdGVcbiAgICBjb25zb2xlLmxvZygnR2V0dGluZyBjZXJ0aWZpY2F0ZSBkZXRhaWxzLi4uJyk7XG4gICAgY29uc3QgY2VydGlmaWNhdGVzID0gYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICBjZXJ0aWZpY2F0ZUlkcy5tYXAoYXN5bmMgKGlkOiBzdHJpbmcpID0+IHtcbiAgICAgICAgY29uc3QgY2VydCA9IGF3YWl0IGNlcnRpZmljYXRlc0NvbnRyYWN0LnZlcmlmeUNlcnRpZmljYXRlKGlkKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpZCxcbiAgICAgICAgICBpcGZzSGFzaDogY2VydC5pcGZzSGFzaCxcbiAgICAgICAgICBpc3N1ZXI6IGNlcnQuaW5zdGl0dXRpb24sXG4gICAgICAgICAgdGltZXN0YW1wOiBjZXJ0Lmlzc3VlZEF0LnRvU3RyaW5nKCksXG4gICAgICAgICAgaXNWYWxpZDogY2VydC5pc1ZhbGlkXG4gICAgICAgIH07XG4gICAgICB9KVxuICAgICk7XG5cbiAgICBjb25zb2xlLmxvZygnQ2VydGlmaWNhdGUgZGV0YWlsczonLCBjZXJ0aWZpY2F0ZXMpO1xuICAgIHJldHVybiBjZXJ0aWZpY2F0ZXM7XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBpbiBnZXRDZXJ0aWZpY2F0ZXM6JywgZXJyb3IpO1xuICAgIGlmIChlcnJvci5yZWFzb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ29udHJhY3QgZXJyb3I6ICR7ZXJyb3IucmVhc29ufWApO1xuICAgIH1cbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGlzVmVyaWZpZWRVc2VyID0gYXN5bmMgKGFkZHJlc3M6IHN0cmluZykgPT4ge1xuICBpZiAoIWFkZHJlc3MgfHwgIWdldEFkZHJlc3MoYWRkcmVzcykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYWRkcmVzcycpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBjb25zdCB7IGlkZW50aXR5Q29udHJhY3QgfSA9IGF3YWl0IGdldENvbnRyYWN0cygpO1xuICAgIHJldHVybiBhd2FpdCBpZGVudGl0eUNvbnRyYWN0LmlzVmVyaWZpZWRVc2VyKGFkZHJlc3MpO1xuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgY2hlY2tpbmcgdmVyaWZpY2F0aW9uIHN0YXR1czonLCBlcnJvcik7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07XG5cbi8vIEFkbWluIGZ1bmN0aW9uc1xuZXhwb3J0IGNvbnN0IGlzT3duZXIgPSBhc3luYyAoYWRkcmVzczogc3RyaW5nKSA9PiB7XG4gIGlmICghYWRkcmVzcyB8fCAhZ2V0QWRkcmVzcyhhZGRyZXNzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhZGRyZXNzJyk7XG4gIH1cblxuICB0cnkge1xuICAgIGNvbnN0IHsgaWRlbnRpdHlDb250cmFjdCB9ID0gYXdhaXQgZ2V0Q29udHJhY3RzKCk7XG4gICAgY29uc3Qgb3duZXIgPSBhd2FpdCBpZGVudGl0eUNvbnRyYWN0Lm93bmVyKCk7XG5cbiAgICAvLyBBZGQgYWRkaXRpb25hbCBjaGVja3NcbiAgICBpZiAoIW93bmVyKSB7XG4gICAgICBjb25zb2xlLndhcm4oJ093bmVyIGFkZHJlc3MgaXMgbnVsbCBvciB1bmRlZmluZWQnKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3duZXIudG9Mb3dlckNhc2UoKSA9PT0gYWRkcmVzcy50b0xvd2VyQ2FzZSgpO1xuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgY2hlY2tpbmcgb3duZXIgc3RhdHVzOicsIGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IHZlcmlmeUluc3RpdHV0aW9uID0gYXN5bmMgKGluc3RpdHV0aW9uQWRkcmVzczogc3RyaW5nKSA9PiB7XG4gIGlmICghaW5zdGl0dXRpb25BZGRyZXNzIHx8ICFnZXRBZGRyZXNzKGluc3RpdHV0aW9uQWRkcmVzcykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5zdGl0dXRpb24gYWRkcmVzcycpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBjb25zdCB7IGlkZW50aXR5Q29udHJhY3QgfSA9IGF3YWl0IGdldENvbnRyYWN0cygpO1xuICAgIGNvbnN0IHR4ID0gYXdhaXQgaWRlbnRpdHlDb250cmFjdC52ZXJpZnlVc2VyKGluc3RpdHV0aW9uQWRkcmVzcyk7XG4gICAgYXdhaXQgdHgud2FpdCgpO1xuICAgIHJldHVybiB0eDtcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHZlcmlmeWluZyBpbnN0aXR1dGlvbjonLCBlcnJvcik7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBnZXRPd25lckFkZHJlc3MgPSBhc3luYyAoKSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgeyBpZGVudGl0eUNvbnRyYWN0IH0gPSBhd2FpdCBnZXRDb250cmFjdHMoKTtcbiAgICBjb25zdCBvd25lciA9IGF3YWl0IGlkZW50aXR5Q29udHJhY3Qub3duZXIoKTtcbiAgICByZXR1cm4gb3duZXI7XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIG93bmVyIGFkZHJlc3M6JywgZXJyb3IpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59O1xuXG4vLyBBZGQgZXhhbSBtYW5hZ2VtZW50IGNvbnRyYWN0IGFkZHJlc3MgYW5kIEFCSVxuY29uc3QgRVhBTV9NQU5BR0VNRU5UX0FERFJFU1MgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19FWEFNX01BTkFHRU1FTlRfQUREUkVTUyB8fCBcIlwiO1xuY29uc3QgRVhBTV9NQU5BR0VNRU5UX0FCSSA9IEV4YW1NYW5hZ2VtZW50QUJJO1xuXG4vLyBBZGQgZXhhbSBtYW5hZ2VtZW50IGZ1bmN0aW9uc1xuZXhwb3J0IGNvbnN0IGNyZWF0ZUV4YW0gPSBhc3luYyAoXG4gIGlkOiBzdHJpbmcsXG4gIHRpdGxlOiBzdHJpbmcsXG4gIGRlc2NyaXB0aW9uOiBzdHJpbmcsXG4gIGRhdGU6IG51bWJlcixcbiAgZHVyYXRpb246IG51bWJlcixcbiAgaXBmc0hhc2g6IHN0cmluZ1xuKSA9PiB7XG4gIHRyeSB7XG4gICAgaWYgKCF3aW5kb3cuZXRoZXJldW0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gZXRoZXJldW0gcHJvdmlkZXIgZm91bmQnKTtcbiAgICB9XG4gICAgY29uc3QgcHJvdmlkZXIgPSBuZXcgZXRoZXJzLkpzb25ScGNQcm92aWRlcihFWFBFQ1RFRF9ORVRXT1JLLnJwY1VybCk7XG4gICAgY29uc3Qgc2lnbmVyID0gYXdhaXQgcHJvdmlkZXIuZ2V0U2lnbmVyKCk7XG4gICAgY29uc3QgY29udHJhY3QgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KEVYQU1fTUFOQUdFTUVOVF9BRERSRVNTLCBFWEFNX01BTkFHRU1FTlRfQUJJLCBzaWduZXIpO1xuXG4gICAgY29uc3QgdHggPSBhd2FpdCBjb250cmFjdC5jcmVhdGVFeGFtKGlkLCB0aXRsZSwgZGVzY3JpcHRpb24sIGRhdGUsIGR1cmF0aW9uLCBpcGZzSGFzaCk7XG4gICAgYXdhaXQgdHgud2FpdCgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNyZWF0aW5nIGV4YW06JywgZXJyb3IpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3Qgc3VibWl0RXhhbVJlc3VsdCA9IGFzeW5jIChcbiAgZXhhbUlkOiBzdHJpbmcsXG4gIHN0dWRlbnQ6IHN0cmluZyxcbiAgc2NvcmU6IG51bWJlcixcbiAgZ3JhZGU6IHN0cmluZyxcbiAgaXBmc0hhc2g6IHN0cmluZ1xuKSA9PiB7XG4gIHRyeSB7XG4gICAgaWYgKCF3aW5kb3cuZXRoZXJldW0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gZXRoZXJldW0gcHJvdmlkZXIgZm91bmQnKTtcbiAgICB9XG4gICAgY29uc3QgcHJvdmlkZXIgPSBuZXcgZXRoZXJzLkpzb25ScGNQcm92aWRlcihFWFBFQ1RFRF9ORVRXT1JLLnJwY1VybCk7XG4gICAgY29uc3Qgc2lnbmVyID0gYXdhaXQgcHJvdmlkZXIuZ2V0U2lnbmVyKCk7XG4gICAgY29uc3QgY29udHJhY3QgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KEVYQU1fTUFOQUdFTUVOVF9BRERSRVNTLCBFWEFNX01BTkFHRU1FTlRfQUJJLCBzaWduZXIpO1xuXG4gICAgY29uc3QgdHggPSBhd2FpdCBjb250cmFjdC5zdWJtaXRFeGFtUmVzdWx0KGV4YW1JZCwgc3R1ZGVudCwgc2NvcmUsIGdyYWRlLCBpcGZzSGFzaCk7XG4gICAgYXdhaXQgdHgud2FpdCgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHN1Ym1pdHRpbmcgZXhhbSByZXN1bHQ6JywgZXJyb3IpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgdXBkYXRlRXhhbVN0YXR1cyA9IGFzeW5jIChleGFtSWQ6IHN0cmluZywgc3RhdHVzOiBzdHJpbmcpID0+IHtcbiAgdHJ5IHtcbiAgICBpZiAoIXdpbmRvdy5ldGhlcmV1bSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBldGhlcmV1bSBwcm92aWRlciBmb3VuZCcpO1xuICAgIH1cbiAgICBjb25zdCBwcm92aWRlciA9IG5ldyBldGhlcnMuSnNvblJwY1Byb3ZpZGVyKEVYUEVDVEVEX05FVFdPUksucnBjVXJsKTtcbiAgICBjb25zdCBzaWduZXIgPSBhd2FpdCBwcm92aWRlci5nZXRTaWduZXIoKTtcbiAgICBjb25zdCBjb250cmFjdCA9IG5ldyBldGhlcnMuQ29udHJhY3QoRVhBTV9NQU5BR0VNRU5UX0FERFJFU1MsIEVYQU1fTUFOQUdFTUVOVF9BQkksIHNpZ25lcik7XG5cbiAgICBjb25zdCB0eCA9IGF3YWl0IGNvbnRyYWN0LnVwZGF0ZUV4YW1TdGF0dXMoZXhhbUlkLCBzdGF0dXMpO1xuICAgIGF3YWl0IHR4LndhaXQoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciB1cGRhdGluZyBleGFtIHN0YXR1czonLCBlcnJvcik7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBnZXRFeGFtID0gYXN5bmMgKGV4YW1JZDogc3RyaW5nKSA9PiB7XG4gIHRyeSB7XG4gICAgaWYgKCF3aW5kb3cuZXRoZXJldW0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gZXRoZXJldW0gcHJvdmlkZXIgZm91bmQnKTtcbiAgICB9XG4gICAgY29uc3QgcHJvdmlkZXIgPSBuZXcgZXRoZXJzLkpzb25ScGNQcm92aWRlcihFWFBFQ1RFRF9ORVRXT1JLLnJwY1VybCk7XG4gICAgY29uc3QgY29udHJhY3QgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KEVYQU1fTUFOQUdFTUVOVF9BRERSRVNTLCBFWEFNX01BTkFHRU1FTlRfQUJJLCBwcm92aWRlcik7XG5cbiAgICBjb25zdCBleGFtID0gYXdhaXQgY29udHJhY3QuZ2V0RXhhbShleGFtSWQpO1xuICAgIHJldHVybiBleGFtO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgZXhhbTonLCBlcnJvcik7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBnZXRFeGFtUmVzdWx0ID0gYXN5bmMgKGV4YW1JZDogc3RyaW5nLCBzdHVkZW50OiBzdHJpbmcpID0+IHtcbiAgdHJ5IHtcbiAgICBpZiAoIXdpbmRvdy5ldGhlcmV1bSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBldGhlcmV1bSBwcm92aWRlciBmb3VuZCcpO1xuICAgIH1cbiAgICBjb25zdCBwcm92aWRlciA9IG5ldyBldGhlcnMuSnNvblJwY1Byb3ZpZGVyKEVYUEVDVEVEX05FVFdPUksucnBjVXJsKTtcbiAgICBjb25zdCBjb250cmFjdCA9IG5ldyBldGhlcnMuQ29udHJhY3QoRVhBTV9NQU5BR0VNRU5UX0FERFJFU1MsIEVYQU1fTUFOQUdFTUVOVF9BQkksIHByb3ZpZGVyKTtcblxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNvbnRyYWN0LmdldEV4YW1SZXN1bHQoZXhhbUlkLCBzdHVkZW50KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgZXhhbSByZXN1bHQ6JywgZXJyb3IpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0SW5zdGl0dXRpb25FeGFtcyA9IGFzeW5jIChpbnN0aXR1dGlvbjogc3RyaW5nKSA9PiB7XG4gIHRyeSB7XG4gICAgaWYgKCF3aW5kb3cuZXRoZXJldW0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gZXRoZXJldW0gcHJvdmlkZXIgZm91bmQnKTtcbiAgICB9XG4gICAgY29uc3QgcHJvdmlkZXIgPSBuZXcgZXRoZXJzLkpzb25ScGNQcm92aWRlcihFWFBFQ1RFRF9ORVRXT1JLLnJwY1VybCk7XG4gICAgY29uc3QgY29udHJhY3QgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KEVYQU1fTUFOQUdFTUVOVF9BRERSRVNTLCBFWEFNX01BTkFHRU1FTlRfQUJJLCBwcm92aWRlcik7XG5cbiAgICBjb25zdCBleGFtcyA9IGF3YWl0IGNvbnRyYWN0LmdldEluc3RpdHV0aW9uRXhhbXMoaW5zdGl0dXRpb24pO1xuICAgIHJldHVybiBleGFtcztcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIGluc3RpdHV0aW9uIGV4YW1zOicsIGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGdldFN0dWRlbnRFeGFtcyA9IGFzeW5jIChzdHVkZW50OiBzdHJpbmcpID0+IHtcbiAgdHJ5IHtcbiAgICBpZiAoIXdpbmRvdy5ldGhlcmV1bSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBldGhlcmV1bSBwcm92aWRlciBmb3VuZCcpO1xuICAgIH1cbiAgICBjb25zdCBwcm92aWRlciA9IG5ldyBldGhlcnMuSnNvblJwY1Byb3ZpZGVyKEVYUEVDVEVEX05FVFdPUksucnBjVXJsKTtcbiAgICBjb25zdCBjb250cmFjdCA9IG5ldyBldGhlcnMuQ29udHJhY3QoRVhBTV9NQU5BR0VNRU5UX0FERFJFU1MsIEVYQU1fTUFOQUdFTUVOVF9BQkksIHByb3ZpZGVyKTtcblxuICAgIGNvbnN0IGV4YW1zID0gYXdhaXQgY29udHJhY3QuZ2V0U3R1ZGVudEV4YW1zKHN0dWRlbnQpO1xuICAgIHJldHVybiBleGFtcztcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBnZXR0aW5nIHN0dWRlbnQgZXhhbXM6JywgZXJyb3IpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgZW5yb2xsU3R1ZGVudCA9IGFzeW5jIChleGFtSWQ6IHN0cmluZywgc3R1ZGVudEFkZHJlc3M6IHN0cmluZykgPT4ge1xuICB0cnkge1xuICAgIGlmICghd2luZG93LmV0aGVyZXVtKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGV0aGVyZXVtIHByb3ZpZGVyIGZvdW5kJyk7XG4gICAgfVxuICAgIGNvbnN0IHByb3ZpZGVyID0gbmV3IGV0aGVycy5Kc29uUnBjUHJvdmlkZXIoRVhQRUNURURfTkVUV09SSy5ycGNVcmwpO1xuICAgIGNvbnN0IHNpZ25lciA9IGF3YWl0IHByb3ZpZGVyLmdldFNpZ25lcigpO1xuICAgIGNvbnN0IGNvbnRyYWN0ID0gbmV3IGV0aGVycy5Db250cmFjdChFWEFNX01BTkFHRU1FTlRfQUREUkVTUywgRVhBTV9NQU5BR0VNRU5UX0FCSSwgc2lnbmVyKTtcblxuICAgIGNvbnN0IHR4ID0gYXdhaXQgY29udHJhY3QuZW5yb2xsU3R1ZGVudChleGFtSWQsIHN0dWRlbnRBZGRyZXNzKTtcbiAgICBhd2FpdCB0eC53YWl0KCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZW5yb2xsaW5nIHN0dWRlbnQ6JywgZXJyb3IpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59OyAiXSwibmFtZXMiOlsiZXRoZXJzIiwiRXhhbU1hbmFnZW1lbnRBQkkiLCJnZXRQcm92aWRlciIsImdldFNpZ25lciIsIkVYUEVDVEVEX05FVFdPUksiLCJnZXRBZGRyZXNzIiwiSWRlbnRpdHlBQkkiLCJDZXJ0aWZpY2F0ZXNBQkkiLCJJREVOVElUWV9DT05UUkFDVF9BRERSRVNTIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX0lERU5USVRZX0NPTlRSQUNUX0FERFJFU1MiLCJDRVJUSUZJQ0FURVNfQ09OVFJBQ1RfQUREUkVTUyIsIk5FWFRfUFVCTElDX0NFUlRJRklDQVRFU19DT05UUkFDVF9BRERSRVNTIiwiVVNFUl9ST0xFUyIsIk5PTkUiLCJTVFVERU5UIiwiSU5TVElUVVRJT04iLCJFTVBMT1lFUiIsInJvbGVNYXAiLCJjb25zb2xlIiwiZXJyb3IiLCJnZXRDb250cmFjdHMiLCJwcm92aWRlciIsInNpZ25lciIsImlkZW50aXR5Q29udHJhY3QiLCJDb250cmFjdCIsImNlcnRpZmljYXRlc0NvbnRyYWN0IiwiRXJyb3IiLCJtZXNzYWdlIiwicmVnaXN0ZXJVc2VyIiwicm9sZSIsImFkZHJlc3MiLCJ0b0xvd2VyQ2FzZSIsImNvbnRyYWN0QWRkcmVzcyIsImNvbnRyYWN0Iiwicm9sZVZhbHVlIiwidW5kZWZpbmVkIiwidHgiLCJ3YWl0Iiwic3RhdHVzIiwidmVyaWZ5VXNlciIsImdldFVzZXJSb2xlIiwiaXNzdWVDZXJ0aWZpY2F0ZSIsInN0dWRlbnRBZGRyZXNzIiwiaXBmc0hhc2giLCJ2ZXJpZnlDZXJ0aWZpY2F0ZSIsImNlcnRpZmljYXRlSWQiLCJpc1ZhbGlkIiwiZ2V0Q2VydGlmaWNhdGVzIiwibG9nIiwiY2VydGlmaWNhdGVJZHMiLCJnZXRTdHVkZW50Q2VydGlmaWNhdGVzIiwibGVuZ3RoIiwiY2VydGlmaWNhdGVzIiwiUHJvbWlzZSIsImFsbCIsIm1hcCIsImlkIiwiY2VydCIsImlzc3VlciIsImluc3RpdHV0aW9uIiwidGltZXN0YW1wIiwiaXNzdWVkQXQiLCJ0b1N0cmluZyIsInJlYXNvbiIsImlzVmVyaWZpZWRVc2VyIiwiaXNPd25lciIsIm93bmVyIiwid2FybiIsInZlcmlmeUluc3RpdHV0aW9uIiwiaW5zdGl0dXRpb25BZGRyZXNzIiwiZ2V0T3duZXJBZGRyZXNzIiwiRVhBTV9NQU5BR0VNRU5UX0FERFJFU1MiLCJORVhUX1BVQkxJQ19FWEFNX01BTkFHRU1FTlRfQUREUkVTUyIsIkVYQU1fTUFOQUdFTUVOVF9BQkkiLCJjcmVhdGVFeGFtIiwidGl0bGUiLCJkZXNjcmlwdGlvbiIsImRhdGUiLCJkdXJhdGlvbiIsIndpbmRvdyIsImV0aGVyZXVtIiwiSnNvblJwY1Byb3ZpZGVyIiwicnBjVXJsIiwic3VibWl0RXhhbVJlc3VsdCIsImV4YW1JZCIsInN0dWRlbnQiLCJzY29yZSIsImdyYWRlIiwidXBkYXRlRXhhbVN0YXR1cyIsImdldEV4YW0iLCJleGFtIiwiZ2V0RXhhbVJlc3VsdCIsInJlc3VsdCIsImdldEluc3RpdHV0aW9uRXhhbXMiLCJleGFtcyIsImdldFN0dWRlbnRFeGFtcyIsImVucm9sbFN0dWRlbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./utils/contracts.ts\n"));

/***/ })

});