"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/index",{

/***/ "./utils/contracts.ts":
/*!****************************!*\
  !*** ./utils/contracts.ts ***!
  \****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createExam: function() { return /* binding */ createExam; },\n/* harmony export */   enrollStudent: function() { return /* binding */ enrollStudent; },\n/* harmony export */   getCertificates: function() { return /* binding */ getCertificates; },\n/* harmony export */   getContracts: function() { return /* binding */ getContracts; },\n/* harmony export */   getExam: function() { return /* binding */ getExam; },\n/* harmony export */   getExamResult: function() { return /* binding */ getExamResult; },\n/* harmony export */   getInstitutionExams: function() { return /* binding */ getInstitutionExams; },\n/* harmony export */   getOwnerAddress: function() { return /* binding */ getOwnerAddress; },\n/* harmony export */   getStudentExams: function() { return /* binding */ getStudentExams; },\n/* harmony export */   getUserRole: function() { return /* binding */ getUserRole; },\n/* harmony export */   isOwner: function() { return /* binding */ isOwner; },\n/* harmony export */   isVerifiedUser: function() { return /* binding */ isVerifiedUser; },\n/* harmony export */   issueCertificate: function() { return /* binding */ issueCertificate; },\n/* harmony export */   registerUser: function() { return /* binding */ registerUser; },\n/* harmony export */   submitExamResult: function() { return /* binding */ submitExamResult; },\n/* harmony export */   updateExamStatus: function() { return /* binding */ updateExamStatus; },\n/* harmony export */   verifyCertificate: function() { return /* binding */ verifyCertificate; },\n/* harmony export */   verifyInstitution: function() { return /* binding */ verifyInstitution; },\n/* harmony export */   verifyUser: function() { return /* binding */ verifyUser; }\n/* harmony export */ });\n/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ethers */ \"./node_modules/ethers/lib.esm/index.js\");\n/* harmony import */ var _constants_abis__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants/abis */ \"./constants/abis.ts\");\n/* harmony import */ var _ethersConfig__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ethersConfig */ \"./utils/ethersConfig.ts\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"./node_modules/process/browser.js\");\n\n\n\n// Contract ABIs\nconst IdentityABI = [\n    \"function registerUser(uint8 _role, string memory _ipfsHash) external\",\n    \"function verifyUser(address _userAddress) external returns (bool)\",\n    \"function getUserRole(address _userAddress) external view returns (uint8)\",\n    \"function isVerifiedUser(address _userAddress) external view returns (bool)\",\n    \"function updateUserIPFS(string memory _newIpfsHash) external\",\n    // \"function owner() external view returns (address)\"\n    \"function owner() view returns (address)\"\n];\nconst CertificatesABI = [\n    \"function issueCertificate(address _studentAddress, string memory _ipfsHash) external returns (bytes32)\",\n    \"function getStudentCertificates(address _student) external view returns (bytes32[])\",\n    \"function verifyCertificate(bytes32 _certificateId) external view returns (address student, address institution, string ipfsHash, uint256 issuedAt, bool isValid)\"\n];\n// Contract addresses from .env\nconst IDENTITY_CONTRACT_ADDRESS = \"0xaaC5DcdAeadEe8aA2eE7C7c6F381AB44948963B5\";\nconst CERTIFICATES_CONTRACT_ADDRESS = \"0x2AA6Bc8e926Ee5ECaA24c3B29cf24A3e32380682\";\n// Role mapping with proper types\nconst USER_ROLES = {\n    NONE: 0,\n    STUDENT: 1,\n    INSTITUTION: 2,\n    EMPLOYER: 3\n};\nconst roleMap = {\n    [USER_ROLES.NONE]: \"none\",\n    [USER_ROLES.STUDENT]: \"student\",\n    [USER_ROLES.INSTITUTION]: \"institution\",\n    [USER_ROLES.EMPLOYER]: \"employer\"\n};\n// Validate environment variables\nif (!IDENTITY_CONTRACT_ADDRESS) {\n    console.error(\"NEXT_PUBLIC_IDENTITY_CONTRACT_ADDRESS is not set in .env\");\n}\nif (!CERTIFICATES_CONTRACT_ADDRESS) {\n    console.error(\"NEXT_PUBLIC_CERTIFICATES_CONTRACT_ADDRESS is not set in .env\");\n}\nconst getContracts = async ()=>{\n    try {\n        const provider = await (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.getProvider)();\n        const signer = await (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.getSigner)();\n        const identityContract = new ethers__WEBPACK_IMPORTED_MODULE_2__.ethers.Contract(IDENTITY_CONTRACT_ADDRESS, IdentityABI, signer);\n        const certificatesContract = new ethers__WEBPACK_IMPORTED_MODULE_2__.ethers.Contract(CERTIFICATES_CONTRACT_ADDRESS, CertificatesABI, signer);\n        return {\n            identityContract,\n            certificatesContract,\n            provider,\n            signer\n        };\n    } catch (error) {\n        console.error(\"Error initializing contracts:\", error);\n        throw new Error(\"Failed to initialize contracts: \".concat(error.message));\n    }\n};\nconst registerUser = async (role)=>{\n    if (!role) {\n        throw new Error(\"Role is required\");\n    }\n    try {\n        const provider = await (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.getProvider)();\n        const signer = await (0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.getSigner)();\n        const contractAddress = \"0xaaC5DcdAeadEe8aA2eE7C7c6F381AB44948963B5\";\n        if (!contractAddress) {\n            throw new Error(\"Contract address is not configured\");\n        }\n        const contract = new ethers__WEBPACK_IMPORTED_MODULE_2__.ethers.Contract(contractAddress, IdentityABI, signer);\n        // Convert role string to enum value\n        const roleMap = {\n            \"student\": 1,\n            \"institution\": 2,\n            \"employer\": 3\n        };\n        const roleValue = roleMap[role.toLowerCase()];\n        if (roleValue === undefined) {\n            throw new Error(\"Invalid role: \".concat(role, \". Must be one of: student, institution, employer\"));\n        }\n        const tx = await contract.registerUser(roleValue, \"\");\n        await tx.wait();\n        return {\n            status: \"success\"\n        };\n    } catch (error) {\n        console.error(\"Registration error:\", error);\n        throw error;\n    }\n};\nconst verifyUser = async (address)=>{\n    if (!address || !(0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.getAddress)(address)) {\n        throw new Error(\"Invalid address\");\n    }\n    try {\n        const { identityContract } = await getContracts();\n        return await identityContract.verifyUser(address);\n    } catch (error) {\n        console.error(\"Error verifying user:\", error);\n        throw new Error(error.message || \"Failed to verify user\");\n    }\n};\nconst getUserRole = async (address)=>{\n    if (!address || !(0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.getAddress)(address)) {\n        throw new Error(\"Invalid address\");\n    }\n    try {\n        const { identityContract } = await getContracts();\n        const roleValue = await identityContract.getUserRole(address);\n        return roleMap[roleValue] || \"none\";\n    } catch (error) {\n        console.error(\"Error getting user role:\", error);\n        return \"none\";\n    }\n};\nconst issueCertificate = async (studentAddress, ipfsHash)=>{\n    if (!studentAddress || !ipfsHash) {\n        throw new Error(\"Student address and IPFS hash are required\");\n    }\n    try {\n        const { certificatesContract } = await getContracts();\n        const tx = await certificatesContract.issueCertificate(studentAddress, ipfsHash);\n        await tx.wait();\n        return tx;\n    } catch (error) {\n        console.error(\"Error issuing certificate:\", error);\n        throw error;\n    }\n};\nconst verifyCertificate = async (certificateId)=>{\n    if (!certificateId) {\n        throw new Error(\"Certificate ID is required\");\n    }\n    try {\n        const { certificatesContract } = await getContracts();\n        const isValid = await certificatesContract.verifyCertificate(certificateId);\n        return isValid;\n    } catch (error) {\n        console.error(\"Error verifying certificate:\", error);\n        throw error;\n    }\n};\nconst getCertificates = async (address)=>{\n    if (!address || !(0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.getAddress)(address)) {\n        throw new Error(\"Invalid address\");\n    }\n    try {\n        console.log(\"Getting certificates for address:\", address);\n        const { certificatesContract } = await getContracts();\n        // Get certificate IDs first\n        console.log(\"Getting certificate IDs...\");\n        const certificateIds = await certificatesContract.getStudentCertificates(address);\n        console.log(\"Certificate IDs:\", certificateIds);\n        if (!certificateIds || certificateIds.length === 0) {\n            console.log(\"No certificates found\");\n            return [];\n        }\n        // Get details for each certificate\n        console.log(\"Getting certificate details...\");\n        const certificates = await Promise.all(certificateIds.map(async (id)=>{\n            const cert = await certificatesContract.verifyCertificate(id);\n            return {\n                id,\n                ipfsHash: cert.ipfsHash,\n                issuer: cert.institution,\n                timestamp: cert.issuedAt.toString(),\n                isValid: cert.isValid\n            };\n        }));\n        console.log(\"Certificate details:\", certificates);\n        return certificates;\n    } catch (error) {\n        console.error(\"Error in getCertificates:\", error);\n        if (error.reason) {\n            throw new Error(\"Contract error: \".concat(error.reason));\n        }\n        throw error;\n    }\n};\nconst isVerifiedUser = async (address)=>{\n    if (!address || !(0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.getAddress)(address)) {\n        throw new Error(\"Invalid address\");\n    }\n    try {\n        const { identityContract } = await getContracts();\n        return await identityContract.isVerifiedUser(address);\n    } catch (error) {\n        console.error(\"Error checking verification status:\", error);\n        throw error;\n    }\n};\n// Admin functions\nconst isOwner = async (address)=>{\n    if (!address || !(0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.getAddress)(address)) {\n        throw new Error(\"Invalid address\");\n    }\n    try {\n        const { identityContract } = await getContracts();\n        const owner = await identityContract.owner();\n        // Add additional checks\n        if (!owner) {\n            console.warn(\"Owner address is null or undefined\");\n            return false;\n        }\n        return owner.toLowerCase() === address.toLowerCase();\n    } catch (error) {\n        console.error(\"Error checking owner status:\", error);\n        throw error;\n    }\n};\nconst verifyInstitution = async (institutionAddress)=>{\n    if (!institutionAddress || !(0,_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.getAddress)(institutionAddress)) {\n        throw new Error(\"Invalid institution address\");\n    }\n    try {\n        const { identityContract } = await getContracts();\n        const tx = await identityContract.verifyUser(institutionAddress);\n        await tx.wait();\n        return tx;\n    } catch (error) {\n        console.error(\"Error verifying institution:\", error);\n        throw error;\n    }\n};\nconst getOwnerAddress = async ()=>{\n    try {\n        const { identityContract } = await getContracts();\n        const owner = await identityContract.owner();\n        return owner;\n    } catch (error) {\n        console.error(\"Error getting owner address:\", error);\n        throw error;\n    }\n};\n// Add exam management contract address and ABI\nconst EXAM_MANAGEMENT_ADDRESS = process.env.NEXT_PUBLIC_EXAM_MANAGEMENT_ADDRESS || \"\";\nconst EXAM_MANAGEMENT_ABI = _constants_abis__WEBPACK_IMPORTED_MODULE_0__.ExamManagementABI;\n// Add exam management functions\nconst createExam = async (id, title, description, date, duration, ipfsHash)=>{\n    try {\n        if (!window.ethereum) {\n            throw new Error(\"No ethereum provider found\");\n        }\n        const provider = new ethers__WEBPACK_IMPORTED_MODULE_2__.ethers.JsonRpcProvider(_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.EXPECTED_NETWORK.rpcUrl);\n        const signer = await provider.getSigner();\n        const contract = new ethers__WEBPACK_IMPORTED_MODULE_2__.ethers.Contract(EXAM_MANAGEMENT_ADDRESS, EXAM_MANAGEMENT_ABI, signer);\n        const tx = await contract.createExam(id, title, description, date, duration, ipfsHash);\n        await tx.wait();\n        return true;\n    } catch (error) {\n        console.error(\"Error creating exam:\", error);\n        throw error;\n    }\n};\nconst submitExamResult = async (examId, student, score, grade, ipfsHash)=>{\n    try {\n        if (!window.ethereum) {\n            throw new Error(\"No ethereum provider found\");\n        }\n        const provider = new ethers__WEBPACK_IMPORTED_MODULE_2__.ethers.JsonRpcProvider(_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.EXPECTED_NETWORK.rpcUrl);\n        const signer = await provider.getSigner();\n        const contract = new ethers__WEBPACK_IMPORTED_MODULE_2__.ethers.Contract(EXAM_MANAGEMENT_ADDRESS, EXAM_MANAGEMENT_ABI, signer);\n        const tx = await contract.submitExamResult(examId, student, score, grade, ipfsHash);\n        await tx.wait();\n        return true;\n    } catch (error) {\n        console.error(\"Error submitting exam result:\", error);\n        throw error;\n    }\n};\nconst updateExamStatus = async (examId, status)=>{\n    try {\n        if (!window.ethereum) {\n            throw new Error(\"No ethereum provider found\");\n        }\n        const provider = new ethers__WEBPACK_IMPORTED_MODULE_2__.ethers.JsonRpcProvider(_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.EXPECTED_NETWORK.rpcUrl);\n        const signer = await provider.getSigner();\n        const contract = new ethers__WEBPACK_IMPORTED_MODULE_2__.ethers.Contract(EXAM_MANAGEMENT_ADDRESS, EXAM_MANAGEMENT_ABI, signer);\n        const tx = await contract.updateExamStatus(examId, status);\n        await tx.wait();\n        return true;\n    } catch (error) {\n        console.error(\"Error updating exam status:\", error);\n        throw error;\n    }\n};\nconst getExam = async (examId)=>{\n    try {\n        if (!window.ethereum) {\n            throw new Error(\"No ethereum provider found\");\n        }\n        const provider = new ethers__WEBPACK_IMPORTED_MODULE_2__.ethers.JsonRpcProvider(_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.EXPECTED_NETWORK.rpcUrl);\n        const contract = new ethers__WEBPACK_IMPORTED_MODULE_2__.ethers.Contract(EXAM_MANAGEMENT_ADDRESS, EXAM_MANAGEMENT_ABI, provider);\n        const exam = await contract.getExam(examId);\n        return exam;\n    } catch (error) {\n        console.error(\"Error getting exam:\", error);\n        throw error;\n    }\n};\nconst getExamResult = async (examId, student)=>{\n    try {\n        if (!window.ethereum) {\n            throw new Error(\"No ethereum provider found\");\n        }\n        const provider = new ethers__WEBPACK_IMPORTED_MODULE_2__.ethers.JsonRpcProvider(_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.EXPECTED_NETWORK.rpcUrl);\n        const contract = new ethers__WEBPACK_IMPORTED_MODULE_2__.ethers.Contract(EXAM_MANAGEMENT_ADDRESS, EXAM_MANAGEMENT_ABI, provider);\n        const result = await contract.getExamResult(examId, student);\n        return result;\n    } catch (error) {\n        console.error(\"Error getting exam result:\", error);\n        throw error;\n    }\n};\nconst getInstitutionExams = async (institution)=>{\n    try {\n        if (!window.ethereum) {\n            throw new Error(\"No ethereum provider found\");\n        }\n        const provider = new ethers__WEBPACK_IMPORTED_MODULE_2__.ethers.JsonRpcProvider(_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.EXPECTED_NETWORK.rpcUrl);\n        const contract = new ethers__WEBPACK_IMPORTED_MODULE_2__.ethers.Contract(EXAM_MANAGEMENT_ADDRESS, EXAM_MANAGEMENT_ABI, provider);\n        const exams = await contract.getInstitutionExams(institution);\n        return exams;\n    } catch (error) {\n        console.error(\"Error getting institution exams:\", error);\n        throw error;\n    }\n};\nconst getStudentExams = async (student)=>{\n    try {\n        if (!window.ethereum) {\n            throw new Error(\"No ethereum provider found\");\n        }\n        const provider = new ethers__WEBPACK_IMPORTED_MODULE_2__.ethers.JsonRpcProvider(_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.EXPECTED_NETWORK.rpcUrl);\n        const contract = new ethers__WEBPACK_IMPORTED_MODULE_2__.ethers.Contract(EXAM_MANAGEMENT_ADDRESS, EXAM_MANAGEMENT_ABI, provider);\n        const exams = await contract.getStudentExams(student);\n        return exams;\n    } catch (error) {\n        console.error(\"Error getting student exams:\", error);\n        throw error;\n    }\n};\nconst enrollStudent = async (examId, studentAddress)=>{\n    try {\n        if (!window.ethereum) {\n            throw new Error(\"No ethereum provider found\");\n        }\n        const provider = new ethers__WEBPACK_IMPORTED_MODULE_2__.ethers.JsonRpcProvider(_ethersConfig__WEBPACK_IMPORTED_MODULE_1__.EXPECTED_NETWORK.rpcUrl);\n        const signer = await provider.getSigner();\n        const contract = new ethers__WEBPACK_IMPORTED_MODULE_2__.ethers.Contract(EXAM_MANAGEMENT_ADDRESS, EXAM_MANAGEMENT_ABI, signer);\n        const tx = await contract.enrollStudent(examId, studentAddress);\n        await tx.wait();\n        return true;\n    } catch (error) {\n        console.error(\"Error enrolling student:\", error);\n        throw error;\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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U3BCLFNBQVM7UUFDdkMsTUFBTThCLFdBQVcsSUFBSWpDLDBDQUFNQSxDQUFDMEIsUUFBUSxDQUFDK0MseUJBQXlCRSxxQkFBcUJuRDtRQUVuRixNQUFNYSxLQUFLLE1BQU1KLFNBQVNpRSxhQUFhLENBQUNaLFFBQVExQztRQUNoRCxNQUFNUCxHQUFHQyxJQUFJO1FBQ2IsT0FBTztJQUNULEVBQUUsT0FBT2pCLE9BQU87UUFDZEQsUUFBUUMsS0FBSyxDQUFDLDRCQUE0QkE7UUFDMUMsTUFBTUE7SUFDUjtBQUNGLEVBQUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vdXRpbHMvY29udHJhY3RzLnRzPzk4NTYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZXRoZXJzIH0gZnJvbSAnZXRoZXJzJztcbmltcG9ydCB7IEV4YW1NYW5hZ2VtZW50QUJJIH0gZnJvbSAnLi4vY29uc3RhbnRzL2FiaXMnO1xuaW1wb3J0IHtcbiAgZ2V0UHJvdmlkZXIsXG4gIGdldFNpZ25lcixcbiAgRVhQRUNURURfTkVUV09SSyxcbiAgdmFsaWRhdGVOZXR3b3JrLFxuICBmb3JtYXRFdGhlcixcbiAgaGFuZGxlQ29udHJhY3RFcnJvcixcbiAgZ2V0QWRkcmVzcyxcbiAgdHlwZSBFdGhlcmV1bVByb3ZpZGVyXG59IGZyb20gJy4vZXRoZXJzQ29uZmlnJztcblxuLy8gQ29udHJhY3QgQUJJc1xuY29uc3QgSWRlbnRpdHlBQkkgPSBbXG4gIFwiZnVuY3Rpb24gcmVnaXN0ZXJVc2VyKHVpbnQ4IF9yb2xlLCBzdHJpbmcgbWVtb3J5IF9pcGZzSGFzaCkgZXh0ZXJuYWxcIixcbiAgXCJmdW5jdGlvbiB2ZXJpZnlVc2VyKGFkZHJlc3MgX3VzZXJBZGRyZXNzKSBleHRlcm5hbCByZXR1cm5zIChib29sKVwiLFxuICBcImZ1bmN0aW9uIGdldFVzZXJSb2xlKGFkZHJlc3MgX3VzZXJBZGRyZXNzKSBleHRlcm5hbCB2aWV3IHJldHVybnMgKHVpbnQ4KVwiLFxuICBcImZ1bmN0aW9uIGlzVmVyaWZpZWRVc2VyKGFkZHJlc3MgX3VzZXJBZGRyZXNzKSBleHRlcm5hbCB2aWV3IHJldHVybnMgKGJvb2wpXCIsXG4gIFwiZnVuY3Rpb24gdXBkYXRlVXNlcklQRlMoc3RyaW5nIG1lbW9yeSBfbmV3SXBmc0hhc2gpIGV4dGVybmFsXCIsXG4gIC8vIFwiZnVuY3Rpb24gb3duZXIoKSBleHRlcm5hbCB2aWV3IHJldHVybnMgKGFkZHJlc3MpXCJcbiAgXCJmdW5jdGlvbiBvd25lcigpIHZpZXcgcmV0dXJucyAoYWRkcmVzcylcIlxuXTtcblxuY29uc3QgQ2VydGlmaWNhdGVzQUJJID0gW1xuICBcImZ1bmN0aW9uIGlzc3VlQ2VydGlmaWNhdGUoYWRkcmVzcyBfc3R1ZGVudEFkZHJlc3MsIHN0cmluZyBtZW1vcnkgX2lwZnNIYXNoKSBleHRlcm5hbCByZXR1cm5zIChieXRlczMyKVwiLFxuICBcImZ1bmN0aW9uIGdldFN0dWRlbnRDZXJ0aWZpY2F0ZXMoYWRkcmVzcyBfc3R1ZGVudCkgZXh0ZXJuYWwgdmlldyByZXR1cm5zIChieXRlczMyW10pXCIsXG4gIFwiZnVuY3Rpb24gdmVyaWZ5Q2VydGlmaWNhdGUoYnl0ZXMzMiBfY2VydGlmaWNhdGVJZCkgZXh0ZXJuYWwgdmlldyByZXR1cm5zIChhZGRyZXNzIHN0dWRlbnQsIGFkZHJlc3MgaW5zdGl0dXRpb24sIHN0cmluZyBpcGZzSGFzaCwgdWludDI1NiBpc3N1ZWRBdCwgYm9vbCBpc1ZhbGlkKVwiXG5dO1xuXG4vLyBDb250cmFjdCBhZGRyZXNzZXMgZnJvbSAuZW52XG5jb25zdCBJREVOVElUWV9DT05UUkFDVF9BRERSRVNTID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfSURFTlRJVFlfQ09OVFJBQ1RfQUREUkVTUztcbmNvbnN0IENFUlRJRklDQVRFU19DT05UUkFDVF9BRERSRVNTID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfQ0VSVElGSUNBVEVTX0NPTlRSQUNUX0FERFJFU1M7XG5cbi8vIFJvbGUgbWFwcGluZyB3aXRoIHByb3BlciB0eXBlc1xuY29uc3QgVVNFUl9ST0xFUyA9IHtcbiAgTk9ORTogMCxcbiAgU1RVREVOVDogMSxcbiAgSU5TVElUVVRJT046IDIsXG4gIEVNUExPWUVSOiAzXG59IGFzIGNvbnN0O1xuXG50eXBlIFJvbGVWYWx1ZSA9IHR5cGVvZiBVU0VSX1JPTEVTW2tleW9mIHR5cGVvZiBVU0VSX1JPTEVTXTtcbnR5cGUgUm9sZVN0cmluZyA9ICdub25lJyB8ICdzdHVkZW50JyB8ICdpbnN0aXR1dGlvbicgfCAnZW1wbG95ZXInO1xuXG5jb25zdCByb2xlTWFwOiBSZWNvcmQ8Um9sZVZhbHVlLCBSb2xlU3RyaW5nPiA9IHtcbiAgW1VTRVJfUk9MRVMuTk9ORV06ICdub25lJyxcbiAgW1VTRVJfUk9MRVMuU1RVREVOVF06ICdzdHVkZW50JyxcbiAgW1VTRVJfUk9MRVMuSU5TVElUVVRJT05dOiAnaW5zdGl0dXRpb24nLFxuICBbVVNFUl9ST0xFUy5FTVBMT1lFUl06ICdlbXBsb3llcidcbn07XG5cbi8vIFZhbGlkYXRlIGVudmlyb25tZW50IHZhcmlhYmxlc1xuaWYgKCFJREVOVElUWV9DT05UUkFDVF9BRERSRVNTKSB7XG4gIGNvbnNvbGUuZXJyb3IoJ05FWFRfUFVCTElDX0lERU5USVRZX0NPTlRSQUNUX0FERFJFU1MgaXMgbm90IHNldCBpbiAuZW52Jyk7XG59XG5pZiAoIUNFUlRJRklDQVRFU19DT05UUkFDVF9BRERSRVNTKSB7XG4gIGNvbnNvbGUuZXJyb3IoJ05FWFRfUFVCTElDX0NFUlRJRklDQVRFU19DT05UUkFDVF9BRERSRVNTIGlzIG5vdCBzZXQgaW4gLmVudicpO1xufVxuXG5leHBvcnQgY29uc3QgZ2V0Q29udHJhY3RzID0gYXN5bmMgKCkgPT4ge1xuICB0cnkge1xuICAgIGNvbnN0IHByb3ZpZGVyID0gYXdhaXQgZ2V0UHJvdmlkZXIoKTtcbiAgICBjb25zdCBzaWduZXIgPSBhd2FpdCBnZXRTaWduZXIoKTtcblxuICAgIGNvbnN0IGlkZW50aXR5Q29udHJhY3QgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KFxuICAgICAgSURFTlRJVFlfQ09OVFJBQ1RfQUREUkVTUyEsXG4gICAgICBJZGVudGl0eUFCSSxcbiAgICAgIHNpZ25lclxuICAgICk7XG5cbiAgICBjb25zdCBjZXJ0aWZpY2F0ZXNDb250cmFjdCA9IG5ldyBldGhlcnMuQ29udHJhY3QoXG4gICAgICBDRVJUSUZJQ0FURVNfQ09OVFJBQ1RfQUREUkVTUyEsXG4gICAgICBDZXJ0aWZpY2F0ZXNBQkksXG4gICAgICBzaWduZXJcbiAgICApO1xuXG4gICAgcmV0dXJuIHsgaWRlbnRpdHlDb250cmFjdCwgY2VydGlmaWNhdGVzQ29udHJhY3QsIHByb3ZpZGVyLCBzaWduZXIgfTtcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluaXRpYWxpemluZyBjb250cmFjdHM6JywgZXJyb3IpO1xuICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIGluaXRpYWxpemUgY29udHJhY3RzOiAke2Vycm9yLm1lc3NhZ2V9YCk7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCByZWdpc3RlclVzZXIgPSBhc3luYyAocm9sZTogc3RyaW5nKSA9PiB7XG4gIGlmICghcm9sZSkge1xuICAgIHRocm93IG5ldyBFcnJvcignUm9sZSBpcyByZXF1aXJlZCcpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBjb25zdCBwcm92aWRlciA9IGF3YWl0IGdldFByb3ZpZGVyKCk7XG4gICAgY29uc3Qgc2lnbmVyID0gYXdhaXQgZ2V0U2lnbmVyKCk7XG4gICAgY29uc3QgY29udHJhY3RBZGRyZXNzID0gcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfSURFTlRJVFlfQ09OVFJBQ1RfQUREUkVTUztcblxuICAgIGlmICghY29udHJhY3RBZGRyZXNzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0NvbnRyYWN0IGFkZHJlc3MgaXMgbm90IGNvbmZpZ3VyZWQnKTtcbiAgICB9XG5cbiAgICBjb25zdCBjb250cmFjdCA9IG5ldyBldGhlcnMuQ29udHJhY3QoY29udHJhY3RBZGRyZXNzLCBJZGVudGl0eUFCSSwgc2lnbmVyKTtcblxuICAgIC8vIENvbnZlcnQgcm9sZSBzdHJpbmcgdG8gZW51bSB2YWx1ZVxuICAgIGNvbnN0IHJvbGVNYXA6IHsgW2tleTogc3RyaW5nXTogbnVtYmVyIH0gPSB7XG4gICAgICAnc3R1ZGVudCc6IDEsXG4gICAgICAnaW5zdGl0dXRpb24nOiAyLFxuICAgICAgJ2VtcGxveWVyJzogM1xuICAgIH07XG5cbiAgICBjb25zdCByb2xlVmFsdWUgPSByb2xlTWFwW3JvbGUudG9Mb3dlckNhc2UoKV07XG4gICAgaWYgKHJvbGVWYWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgcm9sZTogJHtyb2xlfS4gTXVzdCBiZSBvbmUgb2Y6IHN0dWRlbnQsIGluc3RpdHV0aW9uLCBlbXBsb3llcmApO1xuICAgIH1cblxuICAgIGNvbnN0IHR4ID0gYXdhaXQgY29udHJhY3QucmVnaXN0ZXJVc2VyKHJvbGVWYWx1ZSwgXCJcIik7XG4gICAgYXdhaXQgdHgud2FpdCgpO1xuICAgIHJldHVybiB7IHN0YXR1czogJ3N1Y2Nlc3MnIH07XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBjb25zb2xlLmVycm9yKCdSZWdpc3RyYXRpb24gZXJyb3I6JywgZXJyb3IpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgdmVyaWZ5VXNlciA9IGFzeW5jIChhZGRyZXNzOiBzdHJpbmcpID0+IHtcbiAgaWYgKCFhZGRyZXNzIHx8ICFnZXRBZGRyZXNzKGFkZHJlc3MpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFkZHJlc3MnKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgY29uc3QgeyBpZGVudGl0eUNvbnRyYWN0IH0gPSBhd2FpdCBnZXRDb250cmFjdHMoKTtcbiAgICByZXR1cm4gYXdhaXQgaWRlbnRpdHlDb250cmFjdC52ZXJpZnlVc2VyKGFkZHJlc3MpO1xuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgdmVyaWZ5aW5nIHVzZXI6JywgZXJyb3IpO1xuICAgIHRocm93IG5ldyBFcnJvcihlcnJvci5tZXNzYWdlIHx8ICdGYWlsZWQgdG8gdmVyaWZ5IHVzZXInKTtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGdldFVzZXJSb2xlID0gYXN5bmMgKGFkZHJlc3M6IHN0cmluZyk6IFByb21pc2U8Um9sZVN0cmluZz4gPT4ge1xuICBpZiAoIWFkZHJlc3MgfHwgIWdldEFkZHJlc3MoYWRkcmVzcykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYWRkcmVzcycpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBjb25zdCB7IGlkZW50aXR5Q29udHJhY3QgfSA9IGF3YWl0IGdldENvbnRyYWN0cygpO1xuICAgIGNvbnN0IHJvbGVWYWx1ZSA9IGF3YWl0IGlkZW50aXR5Q29udHJhY3QuZ2V0VXNlclJvbGUoYWRkcmVzcyk7XG4gICAgcmV0dXJuIHJvbGVNYXBbcm9sZVZhbHVlIGFzIFJvbGVWYWx1ZV0gfHwgJ25vbmUnO1xuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyB1c2VyIHJvbGU6JywgZXJyb3IpO1xuICAgIHJldHVybiAnbm9uZSc7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBpc3N1ZUNlcnRpZmljYXRlID0gYXN5bmMgKHN0dWRlbnRBZGRyZXNzOiBzdHJpbmcsIGlwZnNIYXNoOiBzdHJpbmcpID0+IHtcbiAgaWYgKCFzdHVkZW50QWRkcmVzcyB8fCAhaXBmc0hhc2gpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1N0dWRlbnQgYWRkcmVzcyBhbmQgSVBGUyBoYXNoIGFyZSByZXF1aXJlZCcpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBjb25zdCB7IGNlcnRpZmljYXRlc0NvbnRyYWN0IH0gPSBhd2FpdCBnZXRDb250cmFjdHMoKTtcbiAgICBjb25zdCB0eCA9IGF3YWl0IGNlcnRpZmljYXRlc0NvbnRyYWN0Lmlzc3VlQ2VydGlmaWNhdGUoc3R1ZGVudEFkZHJlc3MsIGlwZnNIYXNoKTtcbiAgICBhd2FpdCB0eC53YWl0KCk7XG4gICAgcmV0dXJuIHR4O1xuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgaXNzdWluZyBjZXJ0aWZpY2F0ZTonLCBlcnJvcik7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCB2ZXJpZnlDZXJ0aWZpY2F0ZSA9IGFzeW5jIChjZXJ0aWZpY2F0ZUlkOiBzdHJpbmcpID0+IHtcbiAgaWYgKCFjZXJ0aWZpY2F0ZUlkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdDZXJ0aWZpY2F0ZSBJRCBpcyByZXF1aXJlZCcpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBjb25zdCB7IGNlcnRpZmljYXRlc0NvbnRyYWN0IH0gPSBhd2FpdCBnZXRDb250cmFjdHMoKTtcbiAgICBjb25zdCBpc1ZhbGlkID0gYXdhaXQgY2VydGlmaWNhdGVzQ29udHJhY3QudmVyaWZ5Q2VydGlmaWNhdGUoY2VydGlmaWNhdGVJZCk7XG4gICAgcmV0dXJuIGlzVmFsaWQ7XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciB2ZXJpZnlpbmcgY2VydGlmaWNhdGU6JywgZXJyb3IpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0Q2VydGlmaWNhdGVzID0gYXN5bmMgKGFkZHJlc3M6IHN0cmluZykgPT4ge1xuICBpZiAoIWFkZHJlc3MgfHwgIWdldEFkZHJlc3MoYWRkcmVzcykpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgYWRkcmVzcycpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBjb25zb2xlLmxvZygnR2V0dGluZyBjZXJ0aWZpY2F0ZXMgZm9yIGFkZHJlc3M6JywgYWRkcmVzcyk7XG4gICAgY29uc3QgeyBjZXJ0aWZpY2F0ZXNDb250cmFjdCB9ID0gYXdhaXQgZ2V0Q29udHJhY3RzKCk7XG5cbiAgICAvLyBHZXQgY2VydGlmaWNhdGUgSURzIGZpcnN0XG4gICAgY29uc29sZS5sb2coJ0dldHRpbmcgY2VydGlmaWNhdGUgSURzLi4uJyk7XG4gICAgY29uc3QgY2VydGlmaWNhdGVJZHMgPSBhd2FpdCBjZXJ0aWZpY2F0ZXNDb250cmFjdC5nZXRTdHVkZW50Q2VydGlmaWNhdGVzKGFkZHJlc3MpO1xuICAgIGNvbnNvbGUubG9nKCdDZXJ0aWZpY2F0ZSBJRHM6JywgY2VydGlmaWNhdGVJZHMpO1xuXG4gICAgaWYgKCFjZXJ0aWZpY2F0ZUlkcyB8fCBjZXJ0aWZpY2F0ZUlkcy5sZW5ndGggPT09IDApIHtcbiAgICAgIGNvbnNvbGUubG9nKCdObyBjZXJ0aWZpY2F0ZXMgZm91bmQnKTtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICAvLyBHZXQgZGV0YWlscyBmb3IgZWFjaCBjZXJ0aWZpY2F0ZVxuICAgIGNvbnNvbGUubG9nKCdHZXR0aW5nIGNlcnRpZmljYXRlIGRldGFpbHMuLi4nKTtcbiAgICBjb25zdCBjZXJ0aWZpY2F0ZXMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICAgIGNlcnRpZmljYXRlSWRzLm1hcChhc3luYyAoaWQ6IHN0cmluZykgPT4ge1xuICAgICAgICBjb25zdCBjZXJ0ID0gYXdhaXQgY2VydGlmaWNhdGVzQ29udHJhY3QudmVyaWZ5Q2VydGlmaWNhdGUoaWQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlkLFxuICAgICAgICAgIGlwZnNIYXNoOiBjZXJ0LmlwZnNIYXNoLFxuICAgICAgICAgIGlzc3VlcjogY2VydC5pbnN0aXR1dGlvbixcbiAgICAgICAgICB0aW1lc3RhbXA6IGNlcnQuaXNzdWVkQXQudG9TdHJpbmcoKSxcbiAgICAgICAgICBpc1ZhbGlkOiBjZXJ0LmlzVmFsaWRcbiAgICAgICAgfTtcbiAgICAgIH0pXG4gICAgKTtcblxuICAgIGNvbnNvbGUubG9nKCdDZXJ0aWZpY2F0ZSBkZXRhaWxzOicsIGNlcnRpZmljYXRlcyk7XG4gICAgcmV0dXJuIGNlcnRpZmljYXRlcztcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGluIGdldENlcnRpZmljYXRlczonLCBlcnJvcik7XG4gICAgaWYgKGVycm9yLnJlYXNvbikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb250cmFjdCBlcnJvcjogJHtlcnJvci5yZWFzb259YCk7XG4gICAgfVxuICAgIHRocm93IGVycm9yO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgaXNWZXJpZmllZFVzZXIgPSBhc3luYyAoYWRkcmVzczogc3RyaW5nKSA9PiB7XG4gIGlmICghYWRkcmVzcyB8fCAhZ2V0QWRkcmVzcyhhZGRyZXNzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBhZGRyZXNzJyk7XG4gIH1cblxuICB0cnkge1xuICAgIGNvbnN0IHsgaWRlbnRpdHlDb250cmFjdCB9ID0gYXdhaXQgZ2V0Q29udHJhY3RzKCk7XG4gICAgcmV0dXJuIGF3YWl0IGlkZW50aXR5Q29udHJhY3QuaXNWZXJpZmllZFVzZXIoYWRkcmVzcyk7XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjaGVja2luZyB2ZXJpZmljYXRpb24gc3RhdHVzOicsIGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufTtcblxuLy8gQWRtaW4gZnVuY3Rpb25zXG5leHBvcnQgY29uc3QgaXNPd25lciA9IGFzeW5jIChhZGRyZXNzOiBzdHJpbmcpID0+IHtcbiAgaWYgKCFhZGRyZXNzIHx8ICFnZXRBZGRyZXNzKGFkZHJlc3MpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFkZHJlc3MnKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgY29uc3QgeyBpZGVudGl0eUNvbnRyYWN0IH0gPSBhd2FpdCBnZXRDb250cmFjdHMoKTtcbiAgICBjb25zdCBvd25lciA9IGF3YWl0IGlkZW50aXR5Q29udHJhY3Qub3duZXIoKTtcblxuICAgIC8vIEFkZCBhZGRpdGlvbmFsIGNoZWNrc1xuICAgIGlmICghb3duZXIpIHtcbiAgICAgIGNvbnNvbGUud2FybignT3duZXIgYWRkcmVzcyBpcyBudWxsIG9yIHVuZGVmaW5lZCcpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIHJldHVybiBvd25lci50b0xvd2VyQ2FzZSgpID09PSBhZGRyZXNzLnRvTG93ZXJDYXNlKCk7XG4gIH0gY2F0Y2ggKGVycm9yOiBhbnkpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBjaGVja2luZyBvd25lciBzdGF0dXM6JywgZXJyb3IpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgdmVyaWZ5SW5zdGl0dXRpb24gPSBhc3luYyAoaW5zdGl0dXRpb25BZGRyZXNzOiBzdHJpbmcpID0+IHtcbiAgaWYgKCFpbnN0aXR1dGlvbkFkZHJlc3MgfHwgIWdldEFkZHJlc3MoaW5zdGl0dXRpb25BZGRyZXNzKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnN0aXR1dGlvbiBhZGRyZXNzJyk7XG4gIH1cblxuICB0cnkge1xuICAgIGNvbnN0IHsgaWRlbnRpdHlDb250cmFjdCB9ID0gYXdhaXQgZ2V0Q29udHJhY3RzKCk7XG4gICAgY29uc3QgdHggPSBhd2FpdCBpZGVudGl0eUNvbnRyYWN0LnZlcmlmeVVzZXIoaW5zdGl0dXRpb25BZGRyZXNzKTtcbiAgICBhd2FpdCB0eC53YWl0KCk7XG4gICAgcmV0dXJuIHR4O1xuICB9IGNhdGNoIChlcnJvcjogYW55KSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgdmVyaWZ5aW5nIGluc3RpdHV0aW9uOicsIGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGdldE93bmVyQWRkcmVzcyA9IGFzeW5jICgpID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCB7IGlkZW50aXR5Q29udHJhY3QgfSA9IGF3YWl0IGdldENvbnRyYWN0cygpO1xuICAgIGNvbnN0IG93bmVyID0gYXdhaXQgaWRlbnRpdHlDb250cmFjdC5vd25lcigpO1xuICAgIHJldHVybiBvd25lcjtcbiAgfSBjYXRjaCAoZXJyb3I6IGFueSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgb3duZXIgYWRkcmVzczonLCBlcnJvcik7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07XG5cbi8vIEFkZCBleGFtIG1hbmFnZW1lbnQgY29udHJhY3QgYWRkcmVzcyBhbmQgQUJJXG5jb25zdCBFWEFNX01BTkFHRU1FTlRfQUREUkVTUyA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0VYQU1fTUFOQUdFTUVOVF9BRERSRVNTIHx8IFwiXCI7XG5jb25zdCBFWEFNX01BTkFHRU1FTlRfQUJJID0gRXhhbU1hbmFnZW1lbnRBQkk7XG5cbi8vIEFkZCBleGFtIG1hbmFnZW1lbnQgZnVuY3Rpb25zXG5leHBvcnQgY29uc3QgY3JlYXRlRXhhbSA9IGFzeW5jIChcbiAgaWQ6IHN0cmluZyxcbiAgdGl0bGU6IHN0cmluZyxcbiAgZGVzY3JpcHRpb246IHN0cmluZyxcbiAgZGF0ZTogbnVtYmVyLFxuICBkdXJhdGlvbjogbnVtYmVyLFxuICBpcGZzSGFzaDogc3RyaW5nXG4pID0+IHtcbiAgdHJ5IHtcbiAgICBpZiAoIXdpbmRvdy5ldGhlcmV1bSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBldGhlcmV1bSBwcm92aWRlciBmb3VuZCcpO1xuICAgIH1cbiAgICBjb25zdCBwcm92aWRlciA9IG5ldyBldGhlcnMuSnNvblJwY1Byb3ZpZGVyKEVYUEVDVEVEX05FVFdPUksucnBjVXJsKTtcbiAgICBjb25zdCBzaWduZXIgPSBhd2FpdCBwcm92aWRlci5nZXRTaWduZXIoKTtcbiAgICBjb25zdCBjb250cmFjdCA9IG5ldyBldGhlcnMuQ29udHJhY3QoRVhBTV9NQU5BR0VNRU5UX0FERFJFU1MsIEVYQU1fTUFOQUdFTUVOVF9BQkksIHNpZ25lcik7XG5cbiAgICBjb25zdCB0eCA9IGF3YWl0IGNvbnRyYWN0LmNyZWF0ZUV4YW0oaWQsIHRpdGxlLCBkZXNjcmlwdGlvbiwgZGF0ZSwgZHVyYXRpb24sIGlwZnNIYXNoKTtcbiAgICBhd2FpdCB0eC53YWl0KCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgY3JlYXRpbmcgZXhhbTonLCBlcnJvcik7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBzdWJtaXRFeGFtUmVzdWx0ID0gYXN5bmMgKFxuICBleGFtSWQ6IHN0cmluZyxcbiAgc3R1ZGVudDogc3RyaW5nLFxuICBzY29yZTogbnVtYmVyLFxuICBncmFkZTogc3RyaW5nLFxuICBpcGZzSGFzaDogc3RyaW5nXG4pID0+IHtcbiAgdHJ5IHtcbiAgICBpZiAoIXdpbmRvdy5ldGhlcmV1bSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBldGhlcmV1bSBwcm92aWRlciBmb3VuZCcpO1xuICAgIH1cbiAgICBjb25zdCBwcm92aWRlciA9IG5ldyBldGhlcnMuSnNvblJwY1Byb3ZpZGVyKEVYUEVDVEVEX05FVFdPUksucnBjVXJsKTtcbiAgICBjb25zdCBzaWduZXIgPSBhd2FpdCBwcm92aWRlci5nZXRTaWduZXIoKTtcbiAgICBjb25zdCBjb250cmFjdCA9IG5ldyBldGhlcnMuQ29udHJhY3QoRVhBTV9NQU5BR0VNRU5UX0FERFJFU1MsIEVYQU1fTUFOQUdFTUVOVF9BQkksIHNpZ25lcik7XG5cbiAgICBjb25zdCB0eCA9IGF3YWl0IGNvbnRyYWN0LnN1Ym1pdEV4YW1SZXN1bHQoZXhhbUlkLCBzdHVkZW50LCBzY29yZSwgZ3JhZGUsIGlwZnNIYXNoKTtcbiAgICBhd2FpdCB0eC53YWl0KCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3Igc3VibWl0dGluZyBleGFtIHJlc3VsdDonLCBlcnJvcik7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCB1cGRhdGVFeGFtU3RhdHVzID0gYXN5bmMgKGV4YW1JZDogc3RyaW5nLCBzdGF0dXM6IHN0cmluZykgPT4ge1xuICB0cnkge1xuICAgIGlmICghd2luZG93LmV0aGVyZXVtKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGV0aGVyZXVtIHByb3ZpZGVyIGZvdW5kJyk7XG4gICAgfVxuICAgIGNvbnN0IHByb3ZpZGVyID0gbmV3IGV0aGVycy5Kc29uUnBjUHJvdmlkZXIoRVhQRUNURURfTkVUV09SSy5ycGNVcmwpO1xuICAgIGNvbnN0IHNpZ25lciA9IGF3YWl0IHByb3ZpZGVyLmdldFNpZ25lcigpO1xuICAgIGNvbnN0IGNvbnRyYWN0ID0gbmV3IGV0aGVycy5Db250cmFjdChFWEFNX01BTkFHRU1FTlRfQUREUkVTUywgRVhBTV9NQU5BR0VNRU5UX0FCSSwgc2lnbmVyKTtcblxuICAgIGNvbnN0IHR4ID0gYXdhaXQgY29udHJhY3QudXBkYXRlRXhhbVN0YXR1cyhleGFtSWQsIHN0YXR1cyk7XG4gICAgYXdhaXQgdHgud2FpdCgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHVwZGF0aW5nIGV4YW0gc3RhdHVzOicsIGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGdldEV4YW0gPSBhc3luYyAoZXhhbUlkOiBzdHJpbmcpID0+IHtcbiAgdHJ5IHtcbiAgICBpZiAoIXdpbmRvdy5ldGhlcmV1bSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBldGhlcmV1bSBwcm92aWRlciBmb3VuZCcpO1xuICAgIH1cbiAgICBjb25zdCBwcm92aWRlciA9IG5ldyBldGhlcnMuSnNvblJwY1Byb3ZpZGVyKEVYUEVDVEVEX05FVFdPUksucnBjVXJsKTtcbiAgICBjb25zdCBjb250cmFjdCA9IG5ldyBldGhlcnMuQ29udHJhY3QoRVhBTV9NQU5BR0VNRU5UX0FERFJFU1MsIEVYQU1fTUFOQUdFTUVOVF9BQkksIHByb3ZpZGVyKTtcblxuICAgIGNvbnN0IGV4YW0gPSBhd2FpdCBjb250cmFjdC5nZXRFeGFtKGV4YW1JZCk7XG4gICAgcmV0dXJuIGV4YW07XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyBleGFtOicsIGVycm9yKTtcbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufTtcblxuZXhwb3J0IGNvbnN0IGdldEV4YW1SZXN1bHQgPSBhc3luYyAoZXhhbUlkOiBzdHJpbmcsIHN0dWRlbnQ6IHN0cmluZykgPT4ge1xuICB0cnkge1xuICAgIGlmICghd2luZG93LmV0aGVyZXVtKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGV0aGVyZXVtIHByb3ZpZGVyIGZvdW5kJyk7XG4gICAgfVxuICAgIGNvbnN0IHByb3ZpZGVyID0gbmV3IGV0aGVycy5Kc29uUnBjUHJvdmlkZXIoRVhQRUNURURfTkVUV09SSy5ycGNVcmwpO1xuICAgIGNvbnN0IGNvbnRyYWN0ID0gbmV3IGV0aGVycy5Db250cmFjdChFWEFNX01BTkFHRU1FTlRfQUREUkVTUywgRVhBTV9NQU5BR0VNRU5UX0FCSSwgcHJvdmlkZXIpO1xuXG4gICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgY29udHJhY3QuZ2V0RXhhbVJlc3VsdChleGFtSWQsIHN0dWRlbnQpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgZ2V0dGluZyBleGFtIHJlc3VsdDonLCBlcnJvcik7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBnZXRJbnN0aXR1dGlvbkV4YW1zID0gYXN5bmMgKGluc3RpdHV0aW9uOiBzdHJpbmcpID0+IHtcbiAgdHJ5IHtcbiAgICBpZiAoIXdpbmRvdy5ldGhlcmV1bSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBldGhlcmV1bSBwcm92aWRlciBmb3VuZCcpO1xuICAgIH1cbiAgICBjb25zdCBwcm92aWRlciA9IG5ldyBldGhlcnMuSnNvblJwY1Byb3ZpZGVyKEVYUEVDVEVEX05FVFdPUksucnBjVXJsKTtcbiAgICBjb25zdCBjb250cmFjdCA9IG5ldyBldGhlcnMuQ29udHJhY3QoRVhBTV9NQU5BR0VNRU5UX0FERFJFU1MsIEVYQU1fTUFOQUdFTUVOVF9BQkksIHByb3ZpZGVyKTtcblxuICAgIGNvbnN0IGV4YW1zID0gYXdhaXQgY29udHJhY3QuZ2V0SW5zdGl0dXRpb25FeGFtcyhpbnN0aXR1dGlvbik7XG4gICAgcmV0dXJuIGV4YW1zO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgaW5zdGl0dXRpb24gZXhhbXM6JywgZXJyb3IpO1xuICAgIHRocm93IGVycm9yO1xuICB9XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0U3R1ZGVudEV4YW1zID0gYXN5bmMgKHN0dWRlbnQ6IHN0cmluZykgPT4ge1xuICB0cnkge1xuICAgIGlmICghd2luZG93LmV0aGVyZXVtKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGV0aGVyZXVtIHByb3ZpZGVyIGZvdW5kJyk7XG4gICAgfVxuICAgIGNvbnN0IHByb3ZpZGVyID0gbmV3IGV0aGVycy5Kc29uUnBjUHJvdmlkZXIoRVhQRUNURURfTkVUV09SSy5ycGNVcmwpO1xuICAgIGNvbnN0IGNvbnRyYWN0ID0gbmV3IGV0aGVycy5Db250cmFjdChFWEFNX01BTkFHRU1FTlRfQUREUkVTUywgRVhBTV9NQU5BR0VNRU5UX0FCSSwgcHJvdmlkZXIpO1xuXG4gICAgY29uc3QgZXhhbXMgPSBhd2FpdCBjb250cmFjdC5nZXRTdHVkZW50RXhhbXMoc3R1ZGVudCk7XG4gICAgcmV0dXJuIGV4YW1zO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGdldHRpbmcgc3R1ZGVudCBleGFtczonLCBlcnJvcik7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBlbnJvbGxTdHVkZW50ID0gYXN5bmMgKGV4YW1JZDogc3RyaW5nLCBzdHVkZW50QWRkcmVzczogc3RyaW5nKSA9PiB7XG4gIHRyeSB7XG4gICAgaWYgKCF3aW5kb3cuZXRoZXJldW0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignTm8gZXRoZXJldW0gcHJvdmlkZXIgZm91bmQnKTtcbiAgICB9XG4gICAgY29uc3QgcHJvdmlkZXIgPSBuZXcgZXRoZXJzLkpzb25ScGNQcm92aWRlcihFWFBFQ1RFRF9ORVRXT1JLLnJwY1VybCk7XG4gICAgY29uc3Qgc2lnbmVyID0gYXdhaXQgcHJvdmlkZXIuZ2V0U2lnbmVyKCk7XG4gICAgY29uc3QgY29udHJhY3QgPSBuZXcgZXRoZXJzLkNvbnRyYWN0KEVYQU1fTUFOQUdFTUVOVF9BRERSRVNTLCBFWEFNX01BTkFHRU1FTlRfQUJJLCBzaWduZXIpO1xuXG4gICAgY29uc3QgdHggPSBhd2FpdCBjb250cmFjdC5lbnJvbGxTdHVkZW50KGV4YW1JZCwgc3R1ZGVudEFkZHJlc3MpO1xuICAgIGF3YWl0IHR4LndhaXQoKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBlbnJvbGxpbmcgc3R1ZGVudDonLCBlcnJvcik7XG4gICAgdGhyb3cgZXJyb3I7XG4gIH1cbn07ICJdLCJuYW1lcyI6WyJldGhlcnMiLCJFeGFtTWFuYWdlbWVudEFCSSIsImdldFByb3ZpZGVyIiwiZ2V0U2lnbmVyIiwiRVhQRUNURURfTkVUV09SSyIsImdldEFkZHJlc3MiLCJJZGVudGl0eUFCSSIsIkNlcnRpZmljYXRlc0FCSSIsIklERU5USVRZX0NPTlRSQUNUX0FERFJFU1MiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfSURFTlRJVFlfQ09OVFJBQ1RfQUREUkVTUyIsIkNFUlRJRklDQVRFU19DT05UUkFDVF9BRERSRVNTIiwiTkVYVF9QVUJMSUNfQ0VSVElGSUNBVEVTX0NPTlRSQUNUX0FERFJFU1MiLCJVU0VSX1JPTEVTIiwiTk9ORSIsIlNUVURFTlQiLCJJTlNUSVRVVElPTiIsIkVNUExPWUVSIiwicm9sZU1hcCIsImNvbnNvbGUiLCJlcnJvciIsImdldENvbnRyYWN0cyIsInByb3ZpZGVyIiwic2lnbmVyIiwiaWRlbnRpdHlDb250cmFjdCIsIkNvbnRyYWN0IiwiY2VydGlmaWNhdGVzQ29udHJhY3QiLCJFcnJvciIsIm1lc3NhZ2UiLCJyZWdpc3RlclVzZXIiLCJyb2xlIiwiY29udHJhY3RBZGRyZXNzIiwiY29udHJhY3QiLCJyb2xlVmFsdWUiLCJ0b0xvd2VyQ2FzZSIsInVuZGVmaW5lZCIsInR4Iiwid2FpdCIsInN0YXR1cyIsInZlcmlmeVVzZXIiLCJhZGRyZXNzIiwiZ2V0VXNlclJvbGUiLCJpc3N1ZUNlcnRpZmljYXRlIiwic3R1ZGVudEFkZHJlc3MiLCJpcGZzSGFzaCIsInZlcmlmeUNlcnRpZmljYXRlIiwiY2VydGlmaWNhdGVJZCIsImlzVmFsaWQiLCJnZXRDZXJ0aWZpY2F0ZXMiLCJsb2ciLCJjZXJ0aWZpY2F0ZUlkcyIsImdldFN0dWRlbnRDZXJ0aWZpY2F0ZXMiLCJsZW5ndGgiLCJjZXJ0aWZpY2F0ZXMiLCJQcm9taXNlIiwiYWxsIiwibWFwIiwiaWQiLCJjZXJ0IiwiaXNzdWVyIiwiaW5zdGl0dXRpb24iLCJ0aW1lc3RhbXAiLCJpc3N1ZWRBdCIsInRvU3RyaW5nIiwicmVhc29uIiwiaXNWZXJpZmllZFVzZXIiLCJpc093bmVyIiwib3duZXIiLCJ3YXJuIiwidmVyaWZ5SW5zdGl0dXRpb24iLCJpbnN0aXR1dGlvbkFkZHJlc3MiLCJnZXRPd25lckFkZHJlc3MiLCJFWEFNX01BTkFHRU1FTlRfQUREUkVTUyIsIk5FWFRfUFVCTElDX0VYQU1fTUFOQUdFTUVOVF9BRERSRVNTIiwiRVhBTV9NQU5BR0VNRU5UX0FCSSIsImNyZWF0ZUV4YW0iLCJ0aXRsZSIsImRlc2NyaXB0aW9uIiwiZGF0ZSIsImR1cmF0aW9uIiwid2luZG93IiwiZXRoZXJldW0iLCJKc29uUnBjUHJvdmlkZXIiLCJycGNVcmwiLCJzdWJtaXRFeGFtUmVzdWx0IiwiZXhhbUlkIiwic3R1ZGVudCIsInNjb3JlIiwiZ3JhZGUiLCJ1cGRhdGVFeGFtU3RhdHVzIiwiZ2V0RXhhbSIsImV4YW0iLCJnZXRFeGFtUmVzdWx0IiwicmVzdWx0IiwiZ2V0SW5zdGl0dXRpb25FeGFtcyIsImV4YW1zIiwiZ2V0U3R1ZGVudEV4YW1zIiwiZW5yb2xsU3R1ZGVudCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./utils/contracts.ts\n"));

/***/ })

});